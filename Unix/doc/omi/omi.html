<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 5.2, http://www.gnu.org/software/texinfo/ -->
<head>
<title>Open Management Infrastructure (OMI)</title>

<meta name="description" content="Open Management Infrastructure (OMI)">
<meta name="keywords" content="Open Management Infrastructure (OMI)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="#SEC_Contents" rel="contents" title="Table of Contents">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<h1 class="settitle" align="center">Open Management Infrastructure (OMI)</h1>



<a name="SEC_Contents"></a>
<h2 class="contents-heading">Table of Contents</h2>

<div class="contents">
<ul class="no-bullet">
<li><a name="toc-Introduction" href="#Introduction">1 Introduction</a>
<ul class="no-bullet">
  <li><a name="toc-What-is-OMI_003f" href="#What-is-OMI_003f">1.1 What is OMI?</a></li>
  <li><a name="toc-What-does-a-CIM-Server-do_003f" href="#What-does-a-CIM-Server-do_003f">1.2 What does a CIM Server do?</a></li>
  <li><a name="toc-Operations" href="#Operations">1.3 Operations</a></li>
  <li><a name="toc-License" href="#License">1.4 License</a></li>
  <li><a name="toc-Supported-Platforms" href="#Supported-Platforms">1.5 Supported Platforms</a></li>
  <li><a name="toc-Server-Footprint" href="#Server-Footprint">1.6 Server Footprint</a></li>
</ul></li>
<li><a name="toc-Building-and-Installing" href="#Building-and-Installing">2 Building and Installing</a>
<ul class="no-bullet">
  <li><a name="toc-Prerequisites" href="#Prerequisites">2.1 Prerequisites</a></li>
  <li><a name="toc-Overview" href="#Overview">2.2 Overview</a></li>
  <li><a name="toc-Unpacking-the-source-distribution" href="#Unpacking-the-source-distribution">2.3 Unpacking the source distribution</a></li>
  <li><a name="toc-Configuring-the-build" href="#Configuring-the-build">2.4 Configuring the build</a></li>
  <li><a name="toc-Configuring-the-build-outside-the-source-distribution" href="#Configuring-the-build-outside-the-source-distribution">2.5 Configuring the build outside the source distribution</a></li>
  <li><a name="toc-Building-the-distribution" href="#Building-the-distribution">2.6 Building the distribution</a></li>
  <li><a name="toc-Installing-the-distribution" href="#Installing-the-distribution">2.7 Installing the distribution</a></li>
  <li><a name="toc-Uninstalling-the-distribution" href="#Uninstalling-the-distribution">2.8 Uninstalling the distribution</a></li>
  <li><a name="toc-Installing-under-DESTDIR" href="#Installing-under-DESTDIR">2.9 Installing under DESTDIR</a></li>
  <li><a name="toc-Installation-layout" href="#Installation-layout">2.10 Installation layout</a>
  <ul class="no-bullet">
    <li><a name="toc-bin" href="#bin">2.10.1 &lsquo;<samp>bin</samp>&rsquo;</a></li>
    <li><a name="toc-etc" href="#etc">2.10.2 &lsquo;<samp>etc</samp>&rsquo;</a></li>
    <li><a name="toc-lib" href="#lib">2.10.3 &lsquo;<samp>lib</samp>&rsquo;</a></li>
    <li><a name="toc-include" href="#include">2.10.4 &lsquo;<samp>include</samp>&rsquo;</a></li>
    <li><a name="toc-omischema" href="#omischema">2.10.5 &lsquo;<samp>omischema</samp>&rsquo;</a></li>
    <li><a name="toc-etc_002fssl_002fcerts" href="#etc_002fssl_002fcerts">2.10.6 &lsquo;<samp>etc/ssl/certs</samp>&rsquo;</a></li>
    <li><a name="toc-etc_002fomiregister" href="#etc_002fomiregister">2.10.7 &lsquo;<samp>etc/omiregister</samp>&rsquo;</a></li>
    <li><a name="toc-share" href="#share">2.10.8 &lsquo;<samp>share</samp>&rsquo;</a></li>
  </ul></li>
</ul></li>
<li><a name="toc-Using-the-server" href="#Using-the-server">3 Using the server</a>
<ul class="no-bullet">
  <li><a name="toc-Setting-up-your-path" href="#Setting-up-your-path">3.1 Setting up your path</a></li>
  <li><a name="toc-Getting-help" href="#Getting-help">3.2 Getting help</a></li>
  <li><a name="toc-Starting-the-server" href="#Starting-the-server">3.3 Starting the server</a></li>
  <li><a name="toc-Validating-the-server" href="#Validating-the-server">3.4 Validating the server</a></li>
  <li><a name="toc-Stopping-the-server" href="#Stopping-the-server">3.5 Stopping the server</a></li>
  <li><a name="toc-Server-and-Agent-Logs" href="#Server-and-Agent-Logs">3.6 Server and Agent Logs</a></li>
  <li><a name="toc-Server-file-and-directory-locations" href="#Server-file-and-directory-locations">3.7 Server file and directory locations</a></li>
</ul></li>
<li><a name="toc-Using-the-command_002dline-client-_0028omicli_0029" href="#Using-the-command_002dline-client-_0028omicli_0029">4 Using the command-line client (&lsquo;<samp>omicli</samp>&rsquo;)</a>
<ul class="no-bullet">
  <li><a name="toc-Getting-help-on-options" href="#Getting-help-on-options">4.1 Getting help on options</a></li>
  <li><a name="toc-The-socket-file" href="#The-socket-file">4.2 The socket file</a></li>
  <li><a name="toc-The-No_002dOp-request" href="#The-No_002dOp-request">4.3 The No-Op request</a></li>
  <li><a name="toc-Enumerating-Instances" href="#Enumerating-Instances">4.4 Enumerating Instances</a></li>
  <li><a name="toc-Getting-an-Instance" href="#Getting-an-Instance">4.5 Getting an Instance</a></li>
  <li><a name="toc-Invoking-a-method" href="#Invoking-a-method">4.6 Invoking a method</a></li>
  <li><a name="toc-Subscribing-to-an-Indication" href="#Subscribing-to-an-Indication">4.7 Subscribing to an Indication</a>
  <ul class="no-bullet">
    <li><a name="toc-Subscribing-to-an-alert-Indication" href="#Subscribing-to-an-alert-Indication">4.7.1 Subscribing to an alert Indication</a></li>
    <li><a name="toc-Subscribing-to-a-lifecycle-Indication" href="#Subscribing-to-a-lifecycle-Indication">4.7.2 Subscribing to a lifecycle Indication</a></li>
  </ul></li>
</ul></li>
<li><a name="toc-Using-the-client-library-omiclient" href="#Using-the-client-library-omiclient">5 Using the client library &lsquo;<samp>omiclient</samp>&rsquo;</a>
<ul class="no-bullet">
  <li><a name="toc-Client-library-source-examples" href="#Client-library-source-examples">5.1 Client library source examples</a></li>
  <li><a name="toc-The-omiclient-library" href="#The-omiclient-library">5.2 The &lsquo;<samp>omiclient</samp>&rsquo; library</a></li>
  <li><a name="toc-The-_003comiclient_002fclient_002eh_003e-header" href="#The-_003comiclient_002fclient_002eh_003e-header">5.3 The &lsquo;<samp>&lt;omiclient/client.h&gt;</samp>&rsquo; header</a></li>
  <li><a name="toc-Connecting-to-the-local-server" href="#Connecting-to-the-local-server">5.4 Connecting to the local server</a></li>
  <li><a name="toc-Enumerating-instances" href="#Enumerating-instances">5.5 Enumerating instances</a></li>
  <li><a name="toc-Getting-a-single-instance" href="#Getting-a-single-instance">5.6 Getting a single instance</a></li>
  <li><a name="toc-Invoking-an-extrinsic-method" href="#Invoking-an-extrinsic-method">5.7 Invoking an extrinsic method</a></li>
</ul></li>
<li><a name="toc-Using-the-MI-miapi-client-library-and_002for-libmi_002eso" href="#Using-the-MI-miapi-client-library-and_002for-libmi_002eso">6 Using the MI &lsquo;<samp>miapi</samp>&rsquo; client library and/or &lsquo;<samp>libmi.so</samp>&rsquo;</a>
<ul class="no-bullet">
  <li><a name="toc-Introduction-to-the-MI-Library" href="#Introduction-to-the-MI-Library">6.1 Introduction to the MI Library</a>
  <ul class="no-bullet">
    <li><a name="toc-CDXML" href="#CDXML">6.1.1 CDXML</a></li>
    <li><a name="toc-The-MI-Application-Programming-Interface-_0028API_0029" href="#The-MI-Application-Programming-Interface-_0028API_0029">6.1.2 The MI Application Programming Interface (API)</a></li>
  </ul></li>
  <li><a name="toc-Samples-illustrating-MI-library-operations" href="#Samples-illustrating-MI-library-operations">6.2 Samples illustrating MI library operations</a></li>
</ul></li>
<li><a name="toc-Developing-a-provider-in-5-minutes" href="#Developing-a-provider-in-5-minutes">7 Developing a provider in 5 minutes</a>
<ul class="no-bullet">
  <li><a name="toc-Defining-schema_002emof" href="#Defining-schema_002emof">7.1 Defining &lsquo;<samp>schema.mof</samp>&rsquo;</a></li>
  <li><a name="toc-Generating-the-provider-sources" href="#Generating-the-provider-sources">7.2 Generating the provider sources</a>
  <ul class="no-bullet">
    <li><a name="toc-A-Note-about-Context-Object-Lifetime" href="#A-Note-about-Context-Object-Lifetime">7.2.1 A Note about Context Object Lifetime</a></li>
  </ul></li>
  <li><a name="toc-Implementing-the-EnumerateInstances-stub" href="#Implementing-the-EnumerateInstances-stub">7.3 Implementing the &lsquo;<samp>EnumerateInstances</samp>&rsquo; stub</a></li>
  <li><a name="toc-Registering-the-provider" href="#Registering-the-provider">7.4 Registering the provider</a></li>
  <li><a name="toc-Testing-the-provider" href="#Testing-the-provider">7.5 Testing the provider</a></li>
  <li><a name="toc-Going-further" href="#Going-further">7.6 Going further</a></li>
</ul></li>
<li><a name="toc-Developing-providers" href="#Developing-providers">8 Developing providers</a>
<ul class="no-bullet">
  <li><a name="toc-Defining-the-MOF-schema" href="#Defining-the-MOF-schema">8.1 Defining the MOF schema</a></li>
  <li><a name="toc-Generating-the-provider-sources-1" href="#Generating-the-provider-sources-1">8.2 Generating the provider sources</a></li>
  <li><a name="toc-Implementing-the-provider-operations" href="#Implementing-the-provider-operations">8.3 Implementing the provider operations</a>
  <ul class="no-bullet">
    <li><a name="toc-Implementing-enumerate_002dinstances" href="#Implementing-enumerate_002dinstances">8.3.1 Implementing enumerate-instances</a></li>
    <li><a name="toc-Implementing-get_002dinstance" href="#Implementing-get_002dinstance">8.3.2 Implementing get-instance</a></li>
    <li><a name="toc-Implementing-an-extrinsic-method" href="#Implementing-an-extrinsic-method">8.3.3 Implementing an extrinsic method</a></li>
    <li><a name="toc-Implementing-enumerate_002dinstances-for-an-association-provider" href="#Implementing-enumerate_002dinstances-for-an-association-provider">8.3.4 Implementing enumerate-instances for an association provider</a></li>
    <li><a name="toc-Implementing-get_002dinstances-for-an-association-class" href="#Implementing-get_002dinstances-for-an-association-class">8.3.5 Implementing get-instances for an association class</a></li>
    <li><a name="toc-Implementing-the-associator_002dinstances-operation" href="#Implementing-the-associator_002dinstances-operation">8.3.6 Implementing the associator-instances operation</a></li>
    <li><a name="toc-Implementing-the-reference_002dinstances-operation" href="#Implementing-the-reference_002dinstances-operation">8.3.7 Implementing the reference-instances operation</a></li>
    <li><a name="toc-Implementing-indication-operations-_0028experimental_0029" href="#Implementing-indication-operations-_0028experimental_0029">8.3.8 Implementing indication operations (<em>experimental</em>)</a>
    <ul class="no-bullet">
      <li><a name="toc-Implementing-an-alert-indication-_0028experimental_0029" href="#Implementing-an-alert-indication-_0028experimental_0029">8.3.8.1 Implementing an alert indication (<em>experimental</em>)</a></li>
      <li><a name="toc-Implementing-a-lifecycle-indication-_0028experimental_0029" href="#Implementing-a-lifecycle-indication-_0028experimental_0029">8.3.8.2 Implementing a lifecycle indication (<em>experimental</em>)</a></li>
      <li><a name="toc-More-sample-code-for-indications-_0028experimental_0029" href="#More-sample-code-for-indications-_0028experimental_0029">8.3.8.3 More sample code for indications (<em>experimental</em>)</a></li>
    </ul></li>
  </ul></li>
  <li><a name="toc-Building-the-provider" href="#Building-the-provider">8.4 Building the provider</a></li>
  <li><a name="toc-Registering-the-provider-1" href="#Registering-the-provider-1">8.5 Registering the provider</a></li>
  <li><a name="toc-Validating-the-provider" href="#Validating-the-provider">8.6 Validating the provider</a></li>
</ul></li>
<li><a name="toc-Frog-Provider-Sources" href="#Frog-Provider-Sources">Appendix A Frog Provider Sources</a>
<ul class="no-bullet">
  <li><a name="toc-schema_002emof" href="#schema_002emof">A.1 &lsquo;<samp>schema.mof</samp>&rsquo;</a></li>
  <li><a name="toc-XYZ_005fFrog_002eh" href="#XYZ_005fFrog_002eh">A.2 &lsquo;<samp>XYZ_Frog.h</samp>&rsquo;</a></li>
  <li><a name="toc-XYZ_005fFrog_005fClass_005fProvider_002eh" href="#XYZ_005fFrog_005fClass_005fProvider_002eh">A.3 &lsquo;<samp>XYZ_Frog_Class_Provider.h</samp>&rsquo;</a></li>
  <li><a name="toc-XYZ_005fFrog_005fClass_005fProvider_002ecpp" href="#XYZ_005fFrog_005fClass_005fProvider_002ecpp">A.4 &lsquo;<samp>XYZ_Frog_Class_Provider.cpp</samp>&rsquo;</a></li>
  <li><a name="toc-module_002eh" href="#module_002eh">A.5 &lsquo;<samp>module.h</samp>&rsquo;</a></li>
  <li><a name="toc-module_002ecpp" href="#module_002ecpp">A.6 &lsquo;<samp>module.cpp</samp>&rsquo;</a></li>
  <li><a name="toc-schema_002ec" href="#schema_002ec">A.7 &lsquo;<samp>schema.c</samp>&rsquo;</a></li>
  <li><a name="toc-stubs_002ecpp" href="#stubs_002ecpp">A.8 &lsquo;<samp>stubs.cpp</samp>&rsquo;</a></li>
  <li><a name="toc-GNUmakefile" href="#GNUmakefile">A.9 &lsquo;<samp>GNUmakefile</samp>&rsquo;</a></li>
</ul></li>
<li><a name="toc-Asynchronous-Enumerate-Instances-Client-Example" href="#Asynchronous-Enumerate-Instances-Client-Example">Appendix B Asynchronous Enumerate Instances Client Example</a>
<ul class="no-bullet">
  <li><a name="toc-AsyncEnum_002ecpp" href="#AsyncEnum_002ecpp">B.1 &lsquo;<samp>AsyncEnum.cpp</samp>&rsquo;</a></li>
</ul></li>
<li><a name="toc-Cross-compiling-OMI" href="#Cross-compiling-OMI">Appendix C Cross compiling OMI</a>
<ul class="no-bullet">
  <li><a name="toc-Synopsis" href="#Synopsis">C.1 Synopsis</a></li>
  <li><a name="toc-Terminology" href="#Terminology">C.2 Terminology</a></li>
  <li><a name="toc-Configuring" href="#Configuring">C.3 Configuring</a></li>
  <li><a name="toc-Installing" href="#Installing">C.4 Installing</a></li>
</ul></li>
<li><a name="toc-NITS-Integrated-Test-System" href="#NITS-Integrated-Test-System">Appendix D NITS Integrated Test System</a>
<ul class="no-bullet">
  <li><a name="toc-Introduction-1" href="#Introduction-1">D.1 Introduction</a></li>
  <li><a name="toc-Linkage" href="#Linkage">D.2 Linkage</a></li>
  <li><a name="toc-Project-Setup" href="#Project-Setup">D.3 Project Setup</a>
  <ul class="no-bullet">
    <li><a name="toc-Product-Binaries" href="#Product-Binaries">D.3.1 Product Binaries</a></li>
    <li><a name="toc-Unit-Test-Binaries" href="#Unit-Test-Binaries">D.3.2 Unit Test Binaries</a></li>
    <li><a name="toc-Pitfalls_002fNotes" href="#Pitfalls_002fNotes">D.3.3 Pitfalls/Notes</a></li>
    <li><a name="toc-Sample-Project" href="#Sample-Project">D.3.4 Sample Project</a></li>
  </ul></li>
  <li><a name="toc-Deployment" href="#Deployment">D.4 Deployment</a></li>
  <li><a name="toc-How-to-Call-Product-APIs" href="#How-to-Call-Product-APIs">D.5 How to Call Product APIs</a>
  <ul class="no-bullet">
    <li><a name="toc-Public-APIs" href="#Public-APIs">D.5.1 Public APIs</a></li>
    <li><a name="toc-Private-APIs" href="#Private-APIs">D.5.2 Private APIs</a></li>
  </ul></li>
  <li><a name="toc-How-to-Mock-Product-APIs" href="#How-to-Mock-Product-APIs">D.6 How to Mock Product APIs</a></li>
  <li><a name="toc-Command-Line-Interface" href="#Command-Line-Interface">D.7 Command Line Interface</a>
  <ul class="no-bullet">
    <li><a name="toc-Options" href="#Options">D.7.1 Options</a></li>
    <li><a name="toc-Tests" href="#Tests">D.7.2 Tests</a></li>
    <li><a name="toc-Results" href="#Results">D.7.3 Results</a></li>
  </ul></li>
  <li><a name="toc-Implementation" href="#Implementation">D.8 Implementation</a></li>
  <li><a name="toc-A-Selection-of-More-Advanced-Features" href="#A-Selection-of-More-Advanced-Features">D.9 A Selection of More Advanced Features</a>
  <ul class="no-bullet">
    <li><a name="toc-Tracing" href="#Tracing">D.9.1 Tracing</a></li>
    <li><a name="toc-Assertions" href="#Assertions">D.9.2 Assertions</a></li>
    <li><a name="toc-Call-Sites" href="#Call-Sites">D.9.3 Call Sites</a></li>
    <li><a name="toc-Fixtures" href="#Fixtures">D.9.4 Fixtures</a></li>
    <li><a name="toc-Setup-Fixtures" href="#Setup-Fixtures">D.9.5 Setup Fixtures</a>
    <ul class="no-bullet">
      <li><a name="toc-Basic-Setup-Fixtures" href="#Basic-Setup-Fixtures">D.9.5.1 Basic Setup Fixtures</a></li>
      <li><a name="toc-Associating-a-Data-Type-with-a-Setup-Fixture" href="#Associating-a-Data-Type-with-a-Setup-Fixture">D.9.5.2 Associating a Data Type with a Setup Fixture</a></li>
      <li><a name="toc-Setup-Fixture-Composition" href="#Setup-Fixture-Composition">D.9.5.3 Setup Fixture Composition</a></li>
      <li><a name="toc-How-to-Re_002duse-Setup-Fixtures-in-Multiple-Files" href="#How-to-Re_002duse-Setup-Fixtures-in-Multiple-Files">D.9.5.4 How to Re-use Setup Fixtures in Multiple Files</a></li>
    </ul></li>
    <li><a name="toc-Split-Fixtures" href="#Split-Fixtures">D.9.6 Split Fixtures</a></li>
    <li><a name="toc-Test-Fixtures" href="#Test-Fixtures">D.9.7 Test Fixtures</a></li>
    <li><a name="toc-Cleanup-Fixtures" href="#Cleanup-Fixtures">D.9.8 Cleanup Fixtures</a></li>
    <li><a name="toc-ModuleSetup-Fixtures" href="#ModuleSetup-Fixtures">D.9.9 ModuleSetup Fixtures</a></li>
    <li><a name="toc-A-Note-about-C_002b_002b-Tests" href="#A-Note-about-C_002b_002b-Tests">D.9.10 A Note about C++ Tests</a></li>
    <li><a name="toc-Automatic-Fault-Simulation" href="#Automatic-Fault-Simulation">D.9.11 Automatic Fault Simulation</a></li>
  </ul></li>
  <li><a name="toc-Enabling-Logging-during-Unit-Testing-with-NITS" href="#Enabling-Logging-during-Unit-Testing-with-NITS">D.10 Enabling Logging during Unit Testing with NITS</a></li>
</ul></li>

</ul>
</div>


<a name="Introduction"></a>
<h2 class="chapter">1 Introduction</h2>

<p>This manual explains how to get started with OMI. It is by no means a
complete reference, but hopefully after reading it you will be able to:
</p>
<ul>
<li> Build from the source distribution.
</li><li> Install the distribution.
</li><li> Start and stop the server.
</li><li> Use the command-line client.
</li><li> Develop and test a simple provider.
</li><li> Develop a simple client application.
</li></ul>

<a name="What-is-OMI_003f"></a>
<h3 class="section">1.1 What is OMI?</h3>

<p>OMI is a software service that runs on managed nodes. It provides the
manageability infrastructure for building distributed systems management
applications based on DMTF management standards, including:
</p>
<ul>
<li> CIM Infrastructure Specification (DSP0004).
</li><li> CIM Schema (<a href="http://dmtf.org/standards/cim">http://dmtf.org/standards/cim</a>).
</li><li> Generic Operations Specification (DSP0223).
</li><li> WS-Management Protocol (DSP0226, DSP0227, DSP0230;
see also ISO/IEC 17963:2013).
</li></ul>

<p>These standards define:
</p>
<ul>
<li> A <b>meta-model</b> that defines rules for forming classes, properties, methods, 
and instances.
</li><li> A <b>schema</b> that defines specific classes for various management domains 
(<em>e.g.</em> storage, networking, operating systems). The schema is expressed 
using the &quot;Managed Object Format&quot; (DSP0004).
</li><li> The <b>operations</b> that CIM clients may perform on CIM servers.
</li><li> The <b>protocols</b> enabling clients and servers to communicate 
(<em>e.g.</em> WS-Management, CIM-XML).
</li></ul>

<p>A software service that implements these standards is a <b>CIM Server</b>, also
known as a <b>CIM Object Manager (CIMOM)</b>. For more information on these
standards, visit the DMTF (Desktop Management Task Force) web site:
<a href="http://dmtf.org">http://dmtf.org</a>.
</p>
<table class="cartouche" border="1"><tr><td>
<p><b>Note:</b> WBEM (Web-Based Enterprise Management) comprises several standards,
including CIM (Common Information Model) and WS-Management (which is now 
specified in ISO/IEC 17963:2013). <b>WBEM</b> refers
to the broader set of standards. For this reason, the server is named
<b>OMI</b>.
</p></td></tr></table>

<a name="What-does-a-CIM-Server-do_003f"></a>
<h3 class="section">1.2 What does a CIM Server do?</h3>

<p>In general, a CIM server enables client applications to perform operations on
managed resources, such as CPUs, disks, networks, and processes. Typical
operations include:
</p>
<ul>
<li> Enumerating resource instances.
</li><li> Invoking a method on a resource.
</li><li> Subscribing to events on a resources.
</li></ul>

<p>But CIM servers do not perform these operations on resources directly. Instead
servers furnish developers with a framework for building pluggable modules
called <b>providers</b>. Providers are modules that interact directly with one or
more resources. For example, a &quot;process provider&quot; interacts with operating
system processes. Providers are packaged as shared libraries with a main entry
point (used by the server to initialize the provider).
</p>
<a name="Operations"></a>
<h3 class="section">1.3 Operations</h3>

<p>OMI enables clients to perform the following CIM/WBEM operations on providers:
</p>
<ul>
<li> <b>GetInstance</b> - gets a single instance from the server.
</li><li> <b>EnumerateInstances</b> - enumerates instances of a given CIM class.
</li><li> <b>CreateInstance</b> - creates an instance of a CIM class.
</li><li> <b>DeleteInstance</b> - deletes an instance.
</li><li> <b>ModifyInstance</b> - modifies the properties of an instance.
</li><li> <b>Associators</b> - finds instances associated with a given instance.
</li><li> <b>References</b> - finds references that refer to a given instance.
</li><li> <b>Invoke</b> - invokes a method on a given instance or class.
</li><li> <b>Subscribe</b> - subscribes to an Indication class or group of classes.
</li></ul>

<p>OMI clients initiate these operations through these protocols:
</p>
<ul>
<li> The WS-Management protocol
</li><li> The local Binary protocol.
</li><li> The CIM-XML protocol (not supported yet).
</li></ul>

<p>The server accepts client requests and routes them to the appropriate provider.
Provider responses are routed back to the requesting client.
</p>
<a name="License"></a>
<h3 class="section">1.4 License</h3>

<p>OMI software is currently freely available for use by anyone under the terms of
the Apache 2.0 license (<a href="http://www.apache.org/licenses/LICENSE-2.0.txt">http://www.apache.org/licenses/LICENSE-2.0.txt</a>).
</p>
<a name="Supported-Platforms"></a>
<h3 class="section">1.5 Supported Platforms</h3>

<p>OMI supports the following platforms.
</p>
<ul>
<li> HP-UX 11i v2 and v3 (PA-RISC and IA64)
</li><li> Sun Solaris 8 and 9 (SPARC) and Solaris 10 (SPARC and x86)
</li><li> Red Hat Enterprise Linux 4 (x86/x64) and 5 (x86/x64) Server
</li><li> Novell SUSE Linux Enterprise Server 9 (x86) and 10 SP1 (x86/x64)
</li><li> IBM AIX v5.3 and v6.1 (POWER)
</li><li> MacOS 10.5 (Intel)
</li></ul>

<p>OMI also builds on Windows with a few functional limitations.
</p>
<a name="Server-Footprint"></a>
<h3 class="section">1.6 Server Footprint</h3>

<p>OMI was expressly designed to work on very small systems. Conventional CIM 
servers are too large for embedded and mobile operating systems, but OMI will 
fit easily on these systems. Memory consumption is low, and the object size of 
the server is less than 265 kilobytes when built with the following flags:
</p>
<div class="example">
<pre class="example"># ./configure --favorsize --enable-32bit \
   --disable-localsession --enable-sections
</pre></div>

<p>Additional size savings can be achieved by disabling other features if appropriate.
</p>
<a name="Building-and-Installing"></a>
<h2 class="chapter">2 Building and Installing</h2>

<p>This chapter explains how to build and install OMI. It assumes you have
obtained the OMI source distribution (&lsquo;<samp>omi-1.0.0.tar</samp>&rsquo;).
</p>
<table class="cartouche" border="1"><tr><td>
<p><b>Note:</b> Throughout this manual, we use &lsquo;<samp>omi-1.0.0</samp>&rsquo; to represent the OMI
version that you are using. In any of the examples provided, you should 
replace &lsquo;<samp>omi-1.0.0</samp>&rsquo; with your actual OMI version.
</p></td></tr></table>

<a name="Prerequisites"></a>
<h3 class="section">2.1 Prerequisites</h3>

<p>OMI depends on the following software. Be sure these are installed
on your system before building.
</p>
<ul>
<li> GNU make
</li><li> Native C and C++ compiler
</li><li> OpenSSL headers and libraries
</li><li> PAM headers and libraries
</li></ul>

<a name="Overview"></a>
<h3 class="section">2.2 Overview</h3>

<p>The following commands build and install OMI (these steps are expounded
in the sections below). Note again that you should replace &lsquo;<samp>omi-1.0.0</samp>&rsquo; 
with the release version of OMI that you are using.
</p>
<div class="example">
<pre class="example"># tar xf omi-1.0.0.tar
# cd omi-1.0.0
# ./configure
# make
# make install
</pre></div>

<p>The &lsquo;<samp>make install</samp>&rsquo; command installs all files under the
&lsquo;<samp>/opt/omi-1.0.0</samp>&rsquo; directory.
</p>
<a name="Unpacking-the-source-distribution"></a>
<h3 class="section">2.3 Unpacking the source distribution</h3>

<p>The OMI source distribution is a &lsquo;<samp>tar</samp>&rsquo; file. Unpack the distribution
with the &lsquo;<samp>tar</samp>&rsquo; utility as follows:
</p>
<div class="example">
<pre class="example"># tar xf omi-1.0.0.tar
</pre></div>

<p>This command creates a directory named &lsquo;<samp>omi-1.0.0</samp>&rsquo;, which contains the
source distribution.
</p>
<a name="Configuring-the-build"></a>
<h3 class="section">2.4 Configuring the build</h3>

<p>To configure the build, run the &lsquo;<samp>./configure</samp>&rsquo; script from the root of the
source distribution. Type the following to print a help message explaining
how to use the script.
</p>
<div class="example">
<pre class="example"># ./configure --help
</pre></div>

<p>This will also list any new options that have been added in recent releases
of OMI.
</p>
<p>The options allow you to change where components are installed. For example,
to install the programs under &lsquo;<samp>/usr/local/bin</samp>&rsquo; and everything else under
&lsquo;<samp>/opt/omi</samp>&rsquo;, configure as follows.
</p>
<div class="example">
<pre class="example"># ./configure --prefix=/opt/omi --bindir=/usr/local/bin
</pre></div>

<p>The default &lsquo;<samp>prefix</samp>&rsquo; is &lsquo;<samp>/usr/omi-1.0.0</samp>&rsquo;. After installing, you
will find all OMI programs (with a &lsquo;<samp>omi</samp>&rsquo; prefix) under
&lsquo;<samp>/usr/local/bin</samp>&rsquo;.
</p>
<a name="Configuring-the-build-outside-the-source-distribution"></a>
<h3 class="section">2.5 Configuring the build outside the source distribution</h3>

<p>OMI 1.0.6 added support for configuring the build outside of the source
distribution. To do this, create a build directory outside of the source
distribution and then invoke the &lsquo;<samp>configure</samp>&rsquo; script from that build
directory using a relative path. For example (assuming version 1.0.6):
</p>
<div class="example">
<pre class="example"># tar xvf omi-1.0.6.tar
# mkdir build
# cd build
# ../omi-1.0.6/configure
# make
</pre></div>

<a name="Building-the-distribution"></a>
<h3 class="section">2.6 Building the distribution</h3>

<p>After configuring, build by typing &lsquo;<samp>make</samp>&rsquo;, where &lsquo;<samp>make</samp>&rsquo; refers to
GNU make. For example:
</p>
<div class="example">
<pre class="example"># make
</pre></div>

<p>This builds all components.
</p>
<a name="Installing-the-distribution"></a>
<h3 class="section">2.7 Installing the distribution</h3>

<p>After building the source distribution, install by typing:
</p>
<div class="example">
<pre class="example"># make install
</pre></div>

<p>You may configure and build as any user. But you must install as root since
the install script creates files under root-owned directories. Even if the
&lsquo;<samp>--prefix</samp>&rsquo; option specifies a non-root owned directory, the PAM
authentication file (&lsquo;<samp>omi.pam</samp>&rsquo;) must be copied to a root-owned
directory.
</p>
<a name="Uninstalling-the-distribution"></a>
<h3 class="section">2.8 Uninstalling the distribution</h3>

<p>Note that wherever OMI is installed, you will find a script called
&lsquo;<samp>omiuninstall</samp>&rsquo;. This script removes all installed components, but leaves any
third-party components (<em>e.g.</em> providers and registration files) intact.
</p>
<a name="Installing-under-DESTDIR"></a>
<h3 class="section">2.9 Installing under DESTDIR</h3>

<p>Sometimes it is useful to install all the components under a &quot;DESTDIR&quot; for the
purposes of building an RPM or deploying the binaries to a target machine.
For example, consider these steps:
</p>
<div class="example">
<pre class="example">$ ./configure --prefix=/opt/abc
$ make
$ make install DESTDIR=/tmp/destdir
</pre></div>

<p>So instead of installing under:
</p>
<div class="example">
<pre class="example">/opt/abc
</pre></div>

<p>OMI is installed under here instead:
</p>
<div class="example">
<pre class="example">/tmp/destdir/opt/abc
</pre></div>

<p>This procedure isolates all of the installable files for packaging or for
building an install manifest.
</p>
<p>Following the example above, a binary distribution for a given platform can
be created as follows:
</p>
<div class="example">
<pre class="example">$ cd /tmp/destdir/
$ tar cvf omi-1.0.0-linux-x86.tar opt
</pre></div>

<p>Later this can be installed by simply un-tar-ing the package in the root directory
of a Linux system.
</p>
<a name="Installation-layout"></a>
<h3 class="section">2.10 Installation layout</h3>

<p>After installing, you will find the installed files in the locations specified
by the &lsquo;<samp>./configure</samp>&rsquo; options. For example, if you configured with
&lsquo;<samp>./configure --prefix=/opt/omi</samp>&rsquo;, you will find the following files
after installing.
</p>
<div class="example">
<pre class="example">/opt/omi/bin/omicli
/opt/omi/bin/omigen
/opt/omi/bin/omireg
/opt/omi/bin/omiserver
/opt/omi/bin/omiagent
/opt/omi/etc/ssl/certs/omi.pem
/opt/omi/etc/ssl/certs/omikey.pem
/opt/omi/etc/omicli.conf
/opt/omi/etc/omiregister/root-omi/omiidentify.reg
/opt/omi/etc/omigen.conf
/opt/omi/etc/omiserver.conf
/opt/omi/lib/libmicxx.so
/opt/omi/lib/libomiclient.so
/opt/omi/lib/libomiidentify.so
/opt/omi/share/omischema/CIM_Schema.mof
...
/opt/omi/share/omi.mak
/opt/omi/include/MI.h
/opt/omi/include/omiclient/handler.h
/opt/omi/include/omiclient/linkage.h
/opt/omi/include/omiclient/client.h
/opt/omi/include/micxx/atomic.h
/opt/omi/include/micxx/propertyset.h
/opt/omi/include/micxx/dinstance.h
/opt/omi/include/micxx/instance.h
/opt/omi/include/micxx/field.h
/opt/omi/include/micxx/context.h
/opt/omi/include/micxx/datetime.h
/opt/omi/include/micxx/micxx.h
/opt/omi/include/micxx/types.h
/opt/omi/include/micxx/arraytraits.h
/opt/omi/include/micxx/array.h
/opt/omi/include/micxx/linkage.h
/opt/omi/include/micxx/string.h
</pre></div>

<p>In addition to these files, the installer also copies a PAM (Pluggable
Authentication Module) file called &lsquo;<samp>omi.pam</samp>&rsquo; under the
&lsquo;<samp>/etc/pam</samp>&rsquo; directory.
</p>
<p>The following sections discuss these installed files.
</p>
<a name="bin"></a>
<h4 class="subsection">2.10.1 &lsquo;<samp>bin</samp>&rsquo;</h4>

<p>The &lsquo;<samp>bin</samp>&rsquo; directory contains all OMI programs, including:
</p>
<ul>
<li> <code>omiserver</code> &ndash; the server program.
</li><li> <code>omiagent</code> &ndash; the provider agent program.
</li><li> <code>omigen</code> &ndash; the provider generation tool.
</li><li> <code>omireg</code> &ndash; the provider registration tool.
</li><li> <code>omicli</code> &ndash; the command-line client tool.
</li></ul>

<a name="etc"></a>
<h4 class="subsection">2.10.2 &lsquo;<samp>etc</samp>&rsquo;</h4>

<p>The &lsquo;<samp>etc</samp>&rsquo; directory contains system-wide configuration files used by
various programs, including:
</p>
<ul>
<li> <code>omicli.conf</code> &ndash; configuration file for omicli program.
</li><li> <code>omigen.conf</code> &ndash; configuration file for omigen program.
</li><li> <code>omiserver.conf</code> &ndash; configuration file for omiserver program.
</li></ul>

<p>The <code>omicli</code> and <code>omigen</code> programs look first for configuration files
named <code>.omiclirc</code> and <code>.omigenrc</code> in the current and home directories
(in which case the system-wide configuration file is ignored).
</p>
<a name="lib"></a>
<h4 class="subsection">2.10.3 &lsquo;<samp>lib</samp>&rsquo;</h4>

<p>The &lsquo;<samp>lib</samp>&rsquo; directory contains libraries. These include:
</p>
<ul>
<li> <code>libmi.so</code> &ndash; The C-language MI API support library.
<code>libmicxx.so</code> &ndash; the C++ provider support library (<em>Note that this 
library has been deprecated</em>).
</li><li> <code>libomiclient.so</code> &ndash; the C++ binary protocol client library.
</li><li> <code>libomiidentify.so</code> &ndash; the identify provider (OMI_Identify class).
</li></ul>

<a name="include"></a>
<h4 class="subsection">2.10.4 &lsquo;<samp>include</samp>&rsquo;</h4>

<p>The &lsquo;<samp>include</samp>&rsquo; directory contains C and C++ header files required for
provider and client application development. These include:
</p>
<ul>
<li> <code>MI.h</code> &ndash; C provider header file.
</li><li> <code>micxx/micxx.h</code> &ndash; main C++ provider header file (<em>Note that 
this has been deprecated</em>).
</li><li> <code>omiclient/client.h</code> &ndash; main C++ client header file.
</li></ul>

<a name="omischema"></a>
<h4 class="subsection">2.10.5 &lsquo;<samp>omischema</samp>&rsquo;</h4>

<p>The &lsquo;<samp>omischema</samp>&rsquo; directory contains MOF files that define the CIM
schema. These files are used by the provider generator tool (&lsquo;<samp>omigen</samp>&rsquo;)
while generating provider sources. The directory contains hundreds of MOF
files. The main MOF file is called &lsquo;<samp>CIM_Schema.mof</samp>&rsquo; (which includes all
others).
</p>
<p>As of omi-1.0.8, the CIM schema version being used is CIM-2.32.0.
</p>
<a name="etc_002fssl_002fcerts"></a>
<h4 class="subsection">2.10.6 &lsquo;<samp>etc/ssl/certs</samp>&rsquo;</h4>

<p>The &lsquo;<samp>etc/ssl/certs</samp>&rsquo; directory contains PEM-formatted certificates for
SSL (private and public). These include:
</p>
<ul>
<li> <code>omi.pem</code> &ndash; the public certificate.
</li><li> <code>omikey.pem</code> &ndash; the private certificate/key.
</li></ul>

<a name="etc_002fomiregister"></a>
<h4 class="subsection">2.10.7 &lsquo;<samp>etc/omiregister</samp>&rsquo;</h4>

<p>The &lsquo;<samp>etc/omiregister</samp>&rsquo; directory contains a <i>namespace directory</i> for each
CIM namespace. Each namespace directory has the same name as the
corresponding CIM namespace, except &lsquo;<samp>/</samp>&rsquo; characters are translated to
&lsquo;<samp>-</samp>&rsquo; characters. For example, for the CIM namespace &lsquo;<samp>root/cimv2</samp>&rsquo;,
there is a directory named &lsquo;<samp>root-cimv2</samp>&rsquo;. The server scans the
&lsquo;<samp>etc/omiregister</samp>&rsquo; directory during startup to obtain a list of supported
namespaces.
</p>
<p>Each namespace directory contains provider registration files (with a
&lsquo;<samp>.reg</samp>&rsquo; extension). Each registration file corresponds to a single
provider library. These files are created by the &lsquo;<samp>omireg</samp>&rsquo; utility.
The following registration file (named &lsquo;<samp>omiidentify.reg</samp>&rsquo;) registers a
provider that implements the &lsquo;<samp>OMI_Identify</samp>&rsquo; class.
</p>
<div class="example">
<pre class="example">LIBRARY=omiidentify
CLASS=OMI_Identify
</pre></div>

<p>Placing this file in the &lsquo;<samp>etc/omiregister/root-omi</samp>&rsquo; directory, registers
the provider for that namespace. The server scans all namespace directories
to discover provider registrations during startup.
</p>
<a name="share"></a>
<h4 class="subsection">2.10.8 &lsquo;<samp>share</samp>&rsquo;</h4>

<p>The &lsquo;<samp>share</samp>&rsquo; directory contains the &lsquo;<samp>omi.mak</samp>&rsquo; file. This file
is included by provider makefiles generated by the &lsquo;<samp>omigen</samp>&rsquo; tool.
</p>
<a name="Using-the-server"></a>
<h2 class="chapter">3 Using the server</h2>

<p>This chapter explains how to use the server program. It explains how to start,
validate, and stop the server. It also explains various options and where to
find the log files.
</p>
<a name="Setting-up-your-path"></a>
<h3 class="section">3.1 Setting up your path</h3>

<p>You may run each program by specifying its fully-qualified path, or for
convenience, you may wish to add the &lsquo;<samp>bin</samp>&rsquo; directory to your path.
The examples below assume you have done so.
</p>
<a name="Getting-help"></a>
<h3 class="section">3.2 Getting help</h3>

<p>To get help with server options, type the following.
</p>
<div class="example">
<pre class="example"># omiserver -h
</pre></div>

<p>This prints a help message that explains the usage, arguments, and options.
</p>
<a name="Starting-the-server"></a>
<h3 class="section">3.3 Starting the server</h3>

<p>To start the server in the foreground, type this.
</p>
<div class="example">
<pre class="example"># omiserver
</pre></div>

<p>To start the server in the background, use the &lsquo;<samp>-d</samp>&rsquo; (daemonize) option.
</p>
<div class="example">
<pre class="example"># omiserver -d
</pre></div>

<p>Multiple instances of the server may run on the same host subject to the
following constraints:
</p>
<ul>
<li> Each server is built with a distinct installation prefix, so that each
server has a unique PID file and  socket file paths.
</li><li> Each server binds to a distinct port. The port may be set with the
<code>--port</code> command-line option or <code>port</code> configuration file option.
</li></ul>

<p>If these constraints are not met, attempting to run a second server results
in an &quot;already running&quot; message.
</p>
<a name="Validating-the-server"></a>
<h3 class="section">3.4 Validating the server</h3>

<p>To validate that the server is working correctly, use the &lsquo;<samp>omicli</samp>&rsquo; tool
to send it a request. Type &lsquo;<samp>omicli -h</samp>&rsquo; for help with this tool. When
initially installed, the server only has one provider, which provides the
&lsquo;<samp>OMI_Identify</samp>&rsquo; class. To enumerate all instances of this class, type the
following command (&lsquo;<samp>id</samp>&rsquo; is short for &lsquo;<samp>identify</samp>&rsquo;).
</p>
<div class="example">
<pre class="example"># omicli id
</pre></div>

<p>If the server is working properly, this command should print a single instance
to standard output. For example (if the OMI version were 1.0.0):
</p>
<div class="example">
<pre class="verbatim">instance of OMI_Identify
{
    [Key] InstanceID=2FDB5542-5896-45D5-9BE9-DC04430AAABE
    SystemName=linux
    ProductName=OMI 1.0.0
    ProductVendor=Microsoft
    ProductVersionMajor=1
    ProductVersionMinor=0
    ProductVersionRevision=0
    ProductVersionString=1.0.0
    Platform=LINUX_IX86_GNU
    OperatingSystem=LINUX
    Architecture=IX86
    Compiler=GNU
    ConfigPrefix=/tmp/omi
    ConfigLibDir=/tmp/omi/lib
    ConfigBinDir=/tmp/omi/bin
    ConfigIncludeDir=/tmp/omi/include
    ConfigDataDir=/tmp/omi/share
    ConfigLocalStateDir=/tmp/omi/var
    ConfigSysConfDir=/tmp/omi/etc
    ConfigProviderDir=/tmp/omi/etc
    ConfigLogFile=/tmp/omi/var/log/omiserver.log
    ConfigPIDFile=/tmp/omi/var/run/omiserver.pid
    ConfigRegisterDir=/tmp/omi/etc/omiregister
    ConfigSchemaDir=/tmp/omi/share/omischema
    ConfigNameSpaces={root-omi, interop, root-cimv2}
}
</pre></div>

<p>This instance identifies various characteristics of the server and system.
</p>
<a name="Stopping-the-server"></a>
<h3 class="section">3.5 Stopping the server</h3>

<p>To stop the server, type the following.
</p>
<div class="example">
<pre class="example"># omiserver -s
</pre></div>

<p>This stops the server by sending a signal to the process whose process id
(pid) is contained in &lsquo;<samp>var/run/omiserver.pid</samp>&rsquo;. The server removes this file
when it shuts down.
</p>
<a name="Server-and-Agent-Logs"></a>
<h3 class="section">3.6 Server and Agent Logs</h3>

<p>To enable logging, start &lsquo;<samp>omiserver</samp>&rsquo; with the option: 
&lsquo;<samp>âloglevel &lt;level number&gt;</samp>&rsquo;. To generate HTTP &lsquo;<samp>trc</samp>&rsquo; files, start 
&lsquo;<samp>omiserver</samp>&rsquo; with the option: &lsquo;<samp>âhttptrace</samp>&rsquo;. Without these options,
logging and &lsquo;<samp>trc</samp>&rsquo; files will not be enabled.
</p>
<p>Server log messages are directed to &lsquo;<samp>var/log/omiserver.log</samp>&rsquo;. The server
spawns agent processes (&lsquo;<samp>omiagent</samp>&rsquo;) in order to run providers as specified
users (determined by the provider hosting model). Log messages from agents are
written to files whose name has the form:
</p>
<div class="example">
<pre class="example">var/log/omiagent.&lt;UID&gt;.&lt;GID&gt;.log
</pre></div>

<p>&lsquo;<samp>&lt;UID&gt;</samp>&rsquo; and &lsquo;<samp>&lt;GID&gt;</samp>&rsquo; are the user id and group id of the agent
process&rsquo;s owner. To browse logs, look for files under &lsquo;<samp>var/log</samp>&rsquo; whose name
matches &lsquo;<samp>omi*</samp>&rsquo;.
</p>
<a name="Server-file-and-directory-locations"></a>
<h3 class="section">3.7 Server file and directory locations</h3>

<p>Sometimes it is helpful to know where the server expects to find various
files. Where is the server log file? Where is the provider registration
directory? To obtain a list of server and file locations, type the following
command.
</p>
<div class="example">
<pre class="example"># omiserver -p
</pre></div>

<p>Running this on a system where OMI was installed under
&lsquo;<samp>/opt/omi</samp>&rsquo; prints the following.
</p>
<div class="example">
<pre class="verbatim">prefix=/opt/omi
libdir=/opt/omi/lib
bindir=/opt/omi/bin
localstatedir=/opt/omi/var
sysconfdir=/opt/omi/etc
providerdir=/opt/omi/lib
certsdir=/opt/omi/etc/ssl/certs
datadir=/opt/omi/share
rundir=/opt/omi/var/run
logdir=/opt/omi/var/log
schemadir=/opt/omi/share/omischema
schemafile=/opt/omi/share/omischema/CIM_Schema.mof
pidfile=/opt/omi/var/run/omiserver.pid
logfile=/opt/omi/var/log/omiserver.log
registerdir=/opt/omi/etc/omiregister
pemfile=/opt/omi/etc/ssl/certs/omi.pem
keyfile=/opt/omi/etc/ssl/certs/omikey.pem
agentprogram=/opt/omi/bin/omiagent
serverprogram=/opt/omi/bin/omiserver
includedir=/opt/omi/include
configfile=/opt/omi/etc/omiserver.conf
socketfile=/opt/omi/var/omiserver.sock
</pre></div>

<a name="Using-the-command_002dline-client-_0028omicli_0029"></a>
<h2 class="chapter">4 Using the command-line client (&lsquo;<samp>omicli</samp>&rsquo;)</h2>

<p>This chapter explains how to use the command-line client tool. This tool sends
requests to the local CIM server and prints the responses to standard output.
For example, &lsquo;<samp>omicli ei root/omi OMI_Identify</samp>&rsquo; sends the &lsquo;<samp>ei</samp>&rsquo; request
(&lsquo;<samp>enumerate-instances</samp>&rsquo;) to the server and then prints the following on
standard output (assuming, here, that the OMI version is 1.0.0):
</p>
<div class="example">
<pre class="verbatim">instance of OMI_Identify
{
    [Key] InstanceID=2FDB5542-5896-45D5-9BE9-DC04430AAABE
    SystemName=linux
    ProductName=OMI 1.0.0
    ProductVendor=Microsoft
    ProductVersionMajor=1
    ProductVersionMinor=0
    ProductVersionRevision=0
    ProductVersionString=1.0.0
    Platform=LINUX_IX86_GNU
    OperatingSystem=LINUX
    Architecture=IX86
    Compiler=GNU
    ConfigPrefix=/tmp/omi
    ConfigLibDir=/tmp/omi/lib
    ConfigBinDir=/tmp/omi/bin
    ConfigIncludeDir=/tmp/omi/include
    ConfigDataDir=/tmp/omi/share
    ConfigLocalStateDir=/tmp/omi/var
    ConfigSysConfDir=/tmp/omi/etc
    ConfigProviderDir=/tmp/omi/etc
    ConfigLogFile=/tmp/omi/var/log/omiserver.log
    ConfigPIDFile=/tmp/omi/var/run/omiserver.pid
    ConfigRegisterDir=/tmp/omi/etc/omiregister
    ConfigSchemaDir=/tmp/omi/share/omischema
    ConfigNameSpaces={root-omi, interop, root-cimv2}
}
</pre></div>

<p>Each &lsquo;<samp>instance of { ... }</samp>&rsquo; construct represents an instance of a CIM
class. The braces contain properties and their values. Key properties are
annotated with the &lsquo;<samp>Key</samp>&rsquo; qualifier.
</p>
<p>The general usage of the tool is:
</p>
<div class="example">
<pre class="example"># omicli COMMAND ARGUMENTS
</pre></div>

<p>The &lsquo;<samp>COMMAND</samp>&rsquo; is one of the following:
</p>
<ul>
<li> <code>noop</code> &ndash; send a no-op request to the server.
</li><li> <code>gi</code> &ndash; send a get-instance request to the server.
</li><li> <code>ci</code> &ndash; send a create-instance request to the server.
</li><li> <code>mi</code> &ndash; send a modify-instance request to the server.
</li><li> <code>di</code> &ndash; send a delete-instance request to the server.
</li><li> <code>ei</code> &ndash; send an enumerate-instances request to the server.
</li><li> <code>iv</code> &ndash; send an invoke (extrinsic method) request to the server.
</li><li> <code>a</code> &ndash; send an associators request to the server.
</li><li> <code>r</code> &ndash; send an references request to the server.
</li><li> <code>id</code> &ndash; send an identify request to the server.
</li></ul>

<p>The &lsquo;<samp>ARGUMENTS</samp>&rsquo; are command-specific and are described below.
</p>
<a name="Getting-help-on-options"></a>
<h3 class="section">4.1 Getting help on options</h3>

<p>To print a help message, type the following.
</p>
<div class="example">
<pre class="example"># omicli -h
</pre></div>

<p>The message explains the syntax of key commands.
</p>
<a name="The-socket-file"></a>
<h3 class="section">4.2 The socket file</h3>

<p>By default, when &lsquo;<samp>omicli</samp>&rsquo; and &lsquo;<samp>omiserver</samp>&rsquo; are built together (with
the same prefix), the &lsquo;<samp>omicli</samp>&rsquo; program contains the location of the server&rsquo;s
socket file. But when they are built separately, or if you want to communicate
with multiple instances of the server, you must specify the socket file location
using the &lsquo;<samp>--socketfile</samp>&rsquo; option. The socket file is located here:
&lsquo;<samp>*/var/run/omiserver.sock</samp>&rsquo;, where &lsquo;<samp>*</samp>&rsquo; is the prefix the server was built
with.
</p>
<a name="The-No_002dOp-request"></a>
<h3 class="section">4.3 The No-Op request</h3>

<p>The following command sends a no-op request to the server.
</p>
<div class="example">
<pre class="example"># omicli noop
</pre></div>

<p>This tests whether the server is running and responsive. If so, it prints a
message indicating success. If the server is not responsive, the command will
time out.
</p>
<a name="Enumerating-Instances"></a>
<h3 class="section">4.4 Enumerating Instances</h3>

<p>The following command enumerates instances of &lsquo;<samp>OMI_Identify</samp>&rsquo; within
the &lsquo;<samp>root/omi</samp>&rsquo; namespace.
</p>
<div class="example">
<pre class="example"># omicli ei root/omi OMI_Identify
</pre></div>

<a name="Getting-an-Instance"></a>
<h3 class="section">4.5 Getting an Instance</h3>

<p>The following command gets a single instance of the &lsquo;<samp>OMI_Identify</samp>&rsquo; class
from the &lsquo;<samp>root/omi</samp>&rsquo; namespace.
</p>
<div class="example">
<pre class="verbatim"># omicli gi root/omi \
  { OMI_Identify InstanceID 2FDB5542-5896-45D5-9BE9-DC04430AAABE }
</pre></div>

<p>The expression in braces represents the <b>instance name</b> for the given
instance. This instance name has a single key, although an instance name may
have multiple keys. Consider, for example, the following class with two keys.
</p>
<div class="example">
<pre class="verbatim">class MyClass
{
    [Key] String  Key1;
    [Key] Uint32  Key2;
          Boolean Value;
    ...
};
</pre></div>

<p>And now consider the following instance of that class.
</p>
<div class="example">
<pre class="verbatim">instance of MyClass
{
    Key1=XYZ
    Key2=123
    Value=false
    ...
};
</pre></div>

<p>The instance name for this instance is expressed as follows on the command line.
</p>
<div class="example">
<pre class="verbatim">{ MyClass Key1 XYZ Key2 123 *Value false }
</pre></div>

<p>Note that non-key names (such as Value) are prefixed with an asterisk.
</p>
<p>In general, instance names are expressed as a class name followed by name-value
pairs, all enclosed in brackets. Failing to specify values for a complete set
of keys results in an error.
</p>
<a name="Invoking-a-method"></a>
<h3 class="section">4.6 Invoking a method</h3>

<p>To invoke an extrinsic method, use the &lsquo;<samp>iv</samp>&rsquo; command, whose usage is:
</p>
<div class="example">
<pre class="example"># omicli iv NAMESPACE INSTANCENAME METHODNAME PARAMETERS
</pre></div>

<p>For example, consider the &lsquo;<samp>SetState</samp>&rsquo; extrinsic method defined by the
following CIM class.
</p>
<div class="example">
<pre class="verbatim">class OMI_Frog
{
    [Key] Uint32 Key;

    Uint32 SetState(
        [In] String NewState,
        [In(false), Out] String OutState);
};
</pre></div>

<p>The following command invokes the &lsquo;<samp>SetState</samp>&rsquo; method on the instance of
&lsquo;<samp>OMI_Frog</samp>&rsquo; named &lsquo;<samp>{ OMI_Frog Key 123 }</samp>&rsquo;.
</p>
<div class="example">
<pre class="verbatim"># omicli iv root/omi { OMI_Frog Key 123 } SetState { NewState Hopping }
</pre></div>

<p>This command prints any output parameters to standard output. For example, the
above command might print this:
</p>
<div class="example">
<pre class="verbatim">{ OldState Sitting }
</pre></div>


<a name="Subscribing-to-an-Indication"></a>
<h3 class="section">4.7 Subscribing to an Indication</h3>

<p>Use the &lsquo;<samp>queryexpr=&quot;select&quot;</samp>&rsquo; statement to subscribe to an indication, as
illustrated below.
</p>
<a name="Subscribing-to-an-alert-Indication"></a>
<h4 class="subsection">4.7.1 Subscribing to an alert Indication</h4>

<p>An alert indication class derives from the standard &lsquo;<samp>CIM_Indication</samp>&rsquo; class.
For instance:
</p>
<div class="example">
<pre class="verbatim">class XYZ_DiskFault : CIM_Indication
{
  string detailmessage;
};
</pre></div>

<p>In order to subscribe to this &lsquo;<samp>XYZ_DiskFault</samp>&rsquo; indication class, run:
</p>
<div class="example">
<pre class="example"># omicli sub root/sample -queryexpr=&quot;select * from XYZ_DiskFault&quot;
</pre></div>


<a name="Subscribing-to-a-lifecycle-Indication"></a>
<h4 class="subsection">4.7.2 Subscribing to a lifecycle Indication</h4>

<p>Consider as an example a class derived from CIM_Process:
</p>
<div class="example">
<pre class="verbatim">class XYZ_Process : CIM_Process
{
  uint32 runningTime;

  [static]
  uint32 Create( [in] string imageName, [out] CIM_Process REF process );
  uint32 GetRunTime( [in] uint32 pid, [out] uint32 runningTime );
};
</pre></div>

<p>To subscribe to the lifecycle creation indication for instances of the
&lsquo;<samp>XYZ_Process</samp>&rsquo; indication class, run:
</p>
<div class="example">
<pre class="verbatim"># omicli sub root/sample -queryexpr=&quot;select * \
  from CIM_InstCreation \
  where SourceInstance ISA XYZ_Process&quot;
</pre></div>



<a name="Using-the-client-library-omiclient"></a>
<h2 class="chapter">5 Using the client library &lsquo;<samp>omiclient</samp>&rsquo;</h2>

<p>The &lsquo;<samp>omiclient</samp>&rsquo; client library defines a C++ API that enables client
applications to connect to and send requests to the CIM server. It uses a
local binary protocol for communicating with the CIM server. As a result,
the client application must reside on the same host as the CIM server.
This chapter explains how to get started using this library.
</p>
<p>Please note, however, that the  &lsquo;<samp>omiclient</samp>&rsquo; client library is deprecated
and may not be supported in future releases.
</p>
<a name="Client-library-source-examples"></a>
<h3 class="section">5.1 Client library source examples</h3>

<p>The following source files (under the source distribution) illustrate how to
use the client library.
</p>
<div class="example">
<pre class="example">./omiclient/tests/test_client.cpp
./cli/cli.cpp
</pre></div>

<p>The first is the unit test for the &lsquo;<samp>omiclient</samp>&rsquo; library. The second is the
main source file of the &lsquo;<samp>omicli</samp>&rsquo; tool discussed above. The examples below
show how to do simple things with the client library. For more detail, see
these examples.
</p>
<a name="The-omiclient-library"></a>
<h3 class="section">5.2 The &lsquo;<samp>omiclient</samp>&rsquo; library</h3>

<p>The base name of client library is &lsquo;<samp>omiclient</samp>&rsquo;. The full name is platform
dependent. For example, on Linux the full name is &lsquo;<samp>libomiclient.so</samp>&rsquo;. This
library resides in the &lsquo;<samp>lib</samp>&rsquo; directory (selected when the distribution
was built).  The client application must be linked with this library.
</p>
<a name="The-_003comiclient_002fclient_002eh_003e-header"></a>
<h3 class="section">5.3 The &lsquo;<samp>&lt;omiclient/client.h&gt;</samp>&rsquo; header</h3>

<p>Client applications must include &lt;omiclient/client.h&gt;. This header file defines
the full client interface. It resides in the &lsquo;<samp>include</samp>&rsquo; directory (selected
when the distribution was built).
</p>
<a name="Connecting-to-the-local-server"></a>
<h3 class="section">5.4 Connecting to the local server</h3>

<p>The first step is to connect to the local CIM server, illustrated by the
following program.
</p>
<div class="example">
<pre class="verbatim">01  #include &lt;omiclient/client.h&gt;
02
03  using namespace std;
04
05  int main()
06  {
07      const Uint64 timeout = 30000000;
08
09      Client c;
10      String locator;
11      String username;
12      String password;
13
14      if (!c.Connect(locator, username, password, timeout))
15      {
16          // Error!
17      }
18
29      return 0;
20  }
</pre></div>

<p>Line 1 includes &lsquo;<samp>&lt;omiclient/client.h&gt;</samp>&rsquo;, the main header file for the client
interface. This header is located under the installation &lsquo;<samp>include</samp>&rsquo;
directory. Consult this file to more details about the interface.
Use of the &lsquo;<samp>omiclient</samp>&rsquo; library is experimental. The new C client,
&lsquo;<samp>miapi</samp>&rsquo;, provides the same functionality.
</p>
<p>Line 9 instantiates an instance of the &lsquo;<samp>Client</samp>&rsquo; class. This function
takes an optional &lsquo;<samp>Handler</samp>&rsquo; instance, which is required when calling the
asynchronous member functions. The examples below use the synchronous methods
and so no handler is needed.
</p>
<p>Line 14 establishes a synchronous connection with the local CIM server. The
&lsquo;<samp>Client::Connect</samp>&rsquo; function takes four arguments: &lsquo;<samp>locator</samp>&rsquo;,
&lsquo;<samp>username</samp>&rsquo;, &lsquo;<samp>password</samp>&rsquo;, and &lsquo;<samp>timeout</samp>&rsquo;. The &lsquo;<samp>locator</samp>&rsquo; is a
string that specifies the Unix domain socket file used to connect to the
server. If the &lsquo;<samp>locator</samp>&rsquo; is empty, the client uses the default socket
file, located under the &lsquo;<samp>run</samp>&rsquo; directory with the name &lsquo;<samp>omiserver.sock</samp>&rsquo;.
</p>
<p>To connect to a server whose socket file is not in the default location, set
the location parameter to the the full path of that socket file, such as
&lsquo;<samp>/opt/omi/var/run/omiserver.sock</samp>&rsquo;.
</p>
<p>The &lsquo;<samp>username</samp>&rsquo; and &lsquo;<samp>password</samp>&rsquo; parameters are used to authenticate
the user with the server. There are two kinds of authentication: explicit
and implicit. With <strong>explicit</strong> authentication, the &lsquo;<samp>username</samp>&rsquo; and
&lsquo;<samp>password</samp>&rsquo; parameters hold the log on credentials for a given user. With
<strong>implicit</strong> authentication, these parameters are empty, in which case
the user is authenticated using the identity of the current user (obtained
with the &lsquo;<samp>getuid</samp>&rsquo; system call).
</p>
<p>The &lsquo;<samp>timeout</samp>&rsquo; parameter specifies how long to wait (in microseconds)
before failing. In this example, the timeout is 30 seconds (30,000,000
microseconds).
</p>
<p>Developers may call the &lsquo;<samp>Client::Disconnect()</samp>&rsquo; method to explicitly
disconnect from the server. Otherwise, the connection is closed implicitly by
the &lsquo;<samp>Client</samp>&rsquo; destructor.
</p>
<a name="Enumerating-instances"></a>
<h3 class="section">5.5 Enumerating instances</h3>

<p>The code fragment below enumerates instances of the &lsquo;<samp>OMI_Identify</samp>&rsquo; class.
</p>
<div class="example">
<pre class="verbatim">01      const String nameSpace = &quot;root/omi&quot;;
02      const String className = &quot;OMI_Identify&quot;;
03      const bool deepInheritance = true;
04      const Uint64 timeout = 2000000;
05      Array&lt;DInstance&gt; instances;
06      MI_Result result;
07
08      if (!c.EnumerateInstances(nameSpace, className, deepInheritance,
09          timeout, instances, result))
10      {
11          // Error!
12      }
13
14      if (result != MI_RESULT_OK)
15      {
16          // Error!
17      }
18
19      for (Uint32 i = 0; i &lt; instances.GetSize(); i++)
20          instances[i].Print();
</pre></div>

<p>Line 8 performs an enumeration request. It obtains instances of the given
class from the given namespace. The resulting instances are in the
&lsquo;<samp>instances</samp>&rsquo; parameter upon return.
</p>
<p>The &lsquo;<samp>deepInheritance</samp>&rsquo; parameter specifies whether to return instances
of classes derived from &lsquo;<samp>OMI_Identify</samp>&rsquo; (if true) or to return instances
of &lsquo;<samp>OMI_Identify</samp>&rsquo; only (if false).
</p>
<p>Line 19 through 20 print the resulting instances.
</p>
<p>Use &lsquo;<samp>EnumerateInstances</samp>&rsquo; with regard for memory usage. It places all
instances into memory at once, which may exhaust available memory when there
are many thousands of instances. To avoid memory exhaustion, use the
asynchronous form, called &lsquo;<samp>EnumerateInstancesAsync</samp>&rsquo;. All asynchronous
functions use the &lsquo;<samp>Handler</samp>&rsquo; class, which defines virtual functions for
delivering instances one at a time. See Appendix B for a fully asynchronous
example.
</p>
<a name="Getting-a-single-instance"></a>
<h3 class="section">5.6 Getting a single instance</h3>

<p>The code fragment below shows how to get a single instance from the server.
</p>
<div class="example">
<pre class="verbatim">01  // Construct an instance name:
02  const String className = &quot;OMI_Identify&quot;;
03  DInstance instanceName(className, DInstance::CLASS);
04
05  // Add a key property:
06  const String propertyName = &quot;InstanceID&quot;;
07  const String instanceID = &quot;2FDB5542-5896-45D5-9BE9-DC04430AAABE&quot;;
08  const String isNull = false;
09  const String isKey = true;
10  instanceName.AddUint32(propertyName, instanceID, isNull, isKey);
11
12  // Perform get instance:
13  const String nameSpace = &quot;root/omi&quot;;
14  const Uint64 TIMEOUT = 2000000;
15  DInstance instance;
16  MI_Result result;
17  if (!c.GetInstance(nameSpace, instanceName, TIMEOUT, instance,
18      result))
19  {
20      // Error!
21  }
22
23  if (result != MI_RESULT_OK)
24  {
25      // Error!
26  }
27
28  instance.Print();
</pre></div>

<p>Lines 1 through 10 build an instance name (using the &lsquo;<samp>DInstance</samp>&rsquo; class).
Lines 2 through 3 construct a &lsquo;<samp>DInstance</samp>&rsquo; whose class name is
&lsquo;<samp>OMI_Identify</samp>&rsquo;. Lines 6 through 10 add a key property to the instance name
called &lsquo;<samp>InstanceID</samp>&rsquo;.
</p>
<p>Lines 13 through 18 perform the get instance request. Upon return, the
&lsquo;<samp>instance</samp>&rsquo; parameter contains the result.
</p>
<p>Finally, Line 28 prints the resulting instance to standard output.
</p>
<a name="Invoking-an-extrinsic-method"></a>
<h3 class="section">5.7 Invoking an extrinsic method</h3>

<p>This section shows how to invoke an extrinsic method. Recall the definition
of the &lsquo;<samp>OMI_Frog</samp>&rsquo; class.
</p>
<div class="example">
<pre class="verbatim">class OMI_Frog
{
    [Key] Uint32 Key;

    Uint32 SetState(
        [In] String NewState,
        [In(false), Out] String OutState);
};
</pre></div>

<p>The code fragment shows how to invoke the &lsquo;<samp>OMI_Frog.SetState</samp>&rsquo; method.
</p>
<div class="example">
<pre class="verbatim">01  // Initialize instance name:
02  DInstance instanceName(&quot;OMI_Frog&quot;, DInstance::CLASS);
03  instanceName.AddUint32(&quot;Key&quot;, 123, false, true);
04
05  // Initialize input parameters:
06  DInstance in(T(&quot;SetState&quot;), DInstance::METHOD);
07  in.AddString(T(&quot;NewState&quot;), &quot;Hopping&quot;, false, false);
08
09  // Invoke method:
10  const Uint64 TIMEOUT = 5000000;
11  DInstance out;
12  MI_Result result;
13
14  if (!c.Invoke(
15      &quot;root/omi&quot;,
16      instanceName,
17      &quot;SetState&quot;,
18      in,
19      TIMEOUT,
20      out,
21      result))
22  {
23      // Error!
24  }
25
26  if (result != MI_RESULT_OK)
27  {
28      // Error!
29  }
30
31  out.Print();
</pre></div>

<p>Lines 2 through 3 initialize the instance name, which identifies the instance
of &lsquo;<samp>OMI_Frog</samp>&rsquo; whose method will be called. This specifies a single key
named &lsquo;<samp>Key</samp>&rsquo; with the value &lsquo;<samp>123</samp>&rsquo;.
</p>
<p>Lines 6 through 7 initialize the input parameters for the method. In this
example, there is a single parameter named &lsquo;<samp>NewState</samp>&rsquo; with the value
&lsquo;<samp>Hopping</samp>&rsquo;.
</p>
<p>Lines 14 through 21 invoke the &lsquo;<samp>SetState</samp>&rsquo; method. Upon return,
&lsquo;<samp>out</samp>&rsquo; holds any output parameters (the &lsquo;<samp>OldState</samp>&rsquo; parameter
in this case). The &lsquo;<samp>out</samp>&rsquo; parameter always has a parameter named
&lsquo;<samp>MIReturn</samp>&rsquo;, which contains the return value of the function (the return
value of &lsquo;<samp>OMI_Frog.SetState</samp>&rsquo; in this example). In CIM, all functions are
required to return a value.
</p>

<a name="Using-the-MI-miapi-client-library-and_002for-libmi_002eso"></a>
<h2 class="chapter">6 Using the MI &lsquo;<samp>miapi</samp>&rsquo; client library and/or &lsquo;<samp>libmi.so</samp>&rsquo;</h2>

<table class="cartouche" border="1"><tr><td>
<p><b>Note:</b> This information in this chapter is experimental.
</p></td></tr></table>

<a name="Introduction-to-the-MI-Library"></a>
<h3 class="section">6.1 Introduction to the MI Library</h3>

<p>MI on Windows is the Windows Management Infrastructure, also known as WMIv2.
It is documented online in the MSDN Library, at
<a href="http://msdn.microsoft.com/en-us/library/jj152383.aspx">http://msdn.microsoft.com/en-us/library/jj152383.aspx</a>.
</p>
<p>For OMI, the &lsquo;<samp>miapi</samp>&rsquo; client library can be used by including &lsquo;<samp>MI.h</samp>&rsquo; 
in your C source file:
</p>
<div class="example">
<pre class="example">#include &lt;MI.h&gt;
</pre></div>

<p>and by adding the following flags in the GNUmakefile:
</p>
<div class="example">
<pre class="example">âL$Omi/lib âlmi
</pre></div>


<a name="CDXML"></a>
<h4 class="subsection">6.1.1 CDXML</h4>

<p>MI introduces CDXML (cmdlet-definition XML), an XML schema for mapping Windows
PowerShell cmdlets to CIM class operations or methods. PowerShell cmdlet
developers use CDXML files to define cmdlets that call a CIM Object Manager
(CIMOM) server such as WMI in Windows to manage the server.  Cmdlets defined
in CDXML communicate with remote CIM servers using the WsMan protocol,
implemented by the WinRM service in Windows.  This enables management of
end-points that don&rsquo;t have PowerShell installed on them, such as a computer
running Windows Server with PowerShell remoting disabled, or a computer running
a CIM server like OMI or other CIM server software.
</p>
<p>For documentation of CDXML, see
<a href="http://msdn.microsoft.com/en-us/library/jj542522.aspx">http://msdn.microsoft.com/en-us/library/jj542522.aspx</a>.
</p>
<a name="The-MI-Application-Programming-Interface-_0028API_0029"></a>
<h4 class="subsection">6.1.2 The MI Application Programming Interface (API)</h4>

<p>The Management Infrastructure API contains the interfaces, enumerations, 
structures, and unions used to developer native WMI providers and clients.
It is documented online at 
<a href="http://msdn.microsoft.com/en-us/library/hh404805(v=vs.85).aspx">http://msdn.microsoft.com/en-us/library/hh404805(v=vs.85).aspx</a>.
</p>

<a name="Samples-illustrating-MI-library-operations"></a>
<h3 class="section">6.2 Samples illustrating MI library operations</h3>

<p>Examples of MI operations performed using the OMI libraries are located in the 
OMI distribution in the &lsquo;<samp>samples/MIAPI</samp>&rsquo; folder. In general, these examples
show how to perform each operation both synchronously and asynchronously.
</p>
<p>The synchronous example generally calls &lsquo;<samp>MI_Operation_GetInstance</samp>&rsquo; in a
loop to iterate through the results of the operation, whereas the asynchronous
example initializes a &lsquo;<samp>MI_OperationCallbacks</samp>&rsquo; structure with the event and 
callbacks needed to process the results asynchronously.
</p>
<p>The following operations are illustrated:
</p>
<ul>
<li> <b>GetInstance</b> - The &lsquo;<samp>get.c</samp>&rsquo; file shows how to use <br>&lsquo;<samp>MI_Session_GetInstance</samp>&rsquo;.  
</li><li> <b>EnumerateInstances</b> - The &lsquo;<samp>enumerate.c</samp>&rsquo; file shows how to use <br>&lsquo;<samp>MI_Session_EnumerateInstances</samp>&rsquo;.  
</li><li> <b>CreateInstance</b> - The &lsquo;<samp>create.c</samp>&rsquo; file shows how to use <br>&lsquo;<samp>MI_Session_CreateInstance</samp>&rsquo;.
</li><li> <b>DeleteInstance</b> - The &lsquo;<samp>delete.c</samp>&rsquo; file shows how to use <br>&lsquo;<samp>MI_Session_DeleteInstance</samp>&rsquo;.
</li><li> <b>ModifyInstance</b> - The &lsquo;<samp>modify.c</samp>&rsquo; file shows how to use <br>&lsquo;<samp>MI_Session_ModifyInstance</samp>&rsquo;.
</li><li> <b>Associators</b> - The &lsquo;<samp>association.c</samp>&rsquo; file shows how to use <br>&lsquo;<samp>MI_Session_AssociatorInstances</samp>&rsquo;.
</li><li> <b>Invoke</b> - The &lsquo;<samp>invoke.c</samp>&rsquo; file shows how to use <br>&lsquo;<samp>MI_Session_Invoke</samp>&rsquo;.
</li><li> <b>References</b> - The &lsquo;<samp>reference.c</samp>&rsquo; file shows how to use <br>&lsquo;<samp>MI_Session_ReferenceInstances</samp>&rsquo;.
</li><li> <b>Subscribe</b> - The &lsquo;<samp>subscribe.c</samp>&rsquo; file shows how to use <br>&lsquo;<samp>MI_Session_Subscribe</samp>&rsquo;.
</li></ul>



<a name="Developing-a-provider-in-5-minutes"></a>
<h2 class="chapter">7 Developing a provider in 5 minutes</h2>

<p>This chapter provides a very quick overview of the provider development process.
It shows the minimum steps for building a simple instance provider. For a more
complete discussion of provider development, see the next chapter.
</p>
<p>Appendix A contains a complete listing of all file in this example. These files
are also included in the source distribution under
&lsquo;<samp>omi-1.0.0/doc/omi/samples/frog</samp>&rsquo; (assuming OMI version 1.0.0).
</p>
<a name="Defining-schema_002emof"></a>
<h3 class="section">7.1 Defining &lsquo;<samp>schema.mof</samp>&rsquo;</h3>

<p>First we define the class schema shown in the &lsquo;<samp>schema.mof</samp>&rsquo; file below.
</p>
<div class="example">
<pre class="verbatim">class XYZ_Frog
{
    [Key] String Name;
    Uint32 Weight;
    String Color;
};
</pre></div>

<a name="Generating-the-provider-sources"></a>
<h3 class="section">7.2 Generating the provider sources</h3>

<p>Next we generate the provider sources and the makefile using the command
below.
</p>
<div class="example">
<pre class="verbatim">someuser@linux:~/gadget&gt; omigen --cpp -m frog schema.mof XYZ_Frog
Creating XYZ_Frog.h
Creating XYZ_Frog_Class_Provider.h
Creating XYZ_Frog_Class_Provider.cpp
Creating schema.c
Creating stubs.cpp
Creating module.cpp
Creating module.h
Creating GNUmakefile
</pre></div>

<a name="A-Note-about-Context-Object-Lifetime"></a>
<h4 class="subsection">7.2.1 A Note about Context Object Lifetime</h4>

<p>The &lsquo;<samp>stubs.cpp</samp>&rsquo; file that &lsquo;<samp>omigen</samp>&rsquo; produces contains 
wrapper functions that encapsulate an &lsquo;<samp>MI_Context*</samp>&rsquo; pointer
within a context object, and passes that context into the cpp 
skeleton as a reference.
</p>
<p>Because the context object lives on the stack, however, it is 
destroyed as soon as the call rewinds to the caller. Therefore, 
if a provider needs to save the context and use it later, 
the provider must use a copy of the context instead of the
reference to it (which is actually a pointer).
</p>
<p>In the following example, for instance, the call that creates a
new &lsquo;<samp>SCX_Agent_ThreadParam</samp>&rsquo; passes in &lsquo;<samp>context.context( )</samp>&rsquo;
rather than just &lsquo;<samp>context</samp>&rsquo;:
</p>
<div class="example">
<pre class="verbatim">MI_EXTERN_C void MI_CALL SCX_Agent_EnumerateInstances(
    SCX_Agent_Self* self,
    MI_Context* context,
    const MI_Char* nameSpace,
    const MI_Char* className,
    const MI_PropertySet* propertySet,
    MI_Boolean keysOnly,
    const MI_Filter* filter )
{
   SCX_Agent_Class_Provider* cxxSelf =((SCX_Agent_Class_Provider*)self);
   Context  cxxContext(context);
  
   cxxSelf-&gt;EnumerateInstances(
       cxxContext,
       nameSpace,
       __PropertySet(propertySet),
       __bool(keysOnly),
       filter );
}

void SCX_Agent_Class_Provider::EnumerateInstances(
    Context&amp; context,
    const String&amp; nameSpace,
    const PropertySet&amp; propertySet,
    bool keysOnly,
    const MI_Filter* filter)
{
  SCX_PEX_BEGIN
  {
    std::wcout &lt;&lt; &quot;EnumerateInstances: Context: &quot;
               &lt;&lt; &amp;context 
               &lt;&lt; &quot;, keysOnly: &quot; 
               &lt;&lt; keysOnly 
               &lt;&lt; std::endl;
    SCX_Agent_ThreadParam* params = 
        new SCX_Agent_ThreadParam( context.context( ), keysOnly );
    new SCXCoreLib::SCXThread( EnumerateInstancesThreadBody, params );
  }
  SCX_PEX_END( L&quot;SCX_Agent_Class_Provider::EnumerateInstances&quot;,
               SCXCore::g_MetaProvider.GetLogHandle( ) );
}
</pre></div>


<a name="Implementing-the-EnumerateInstances-stub"></a>
<h3 class="section">7.3 Implementing the &lsquo;<samp>EnumerateInstances</samp>&rsquo; stub</h3>

<p>Next we implement the &lsquo;<samp>EnumerateInstances</samp>&rsquo; stub. The generated stub looks
like this:
</p>
<div class="example">
<pre class="verbatim">void XYZ_Frog_Class_Provider::EnumerateInstances(
    Context&amp; context,
    const String&amp; nameSpace,
    const PropertySet&amp; propertySet,
    bool keysOnly,
    const MI_Filter* filter)
{
    context.Post(MI_RESULT_NOT_SUPPORTED);
}
</pre></div>

<p>The implementation below provides two frogs.
</p>
<div class="example">
<pre class="verbatim">void XYZ_Frog_Class_Provider::EnumerateInstances(
    Context&amp; context,
    const String&amp; nameSpace,
    const PropertySet&amp; propertySet,
    bool keysOnly,
    const MI_Filter* filter)
{
    XYZ_Frog_Class frog1;
    frog1.Name_value(&quot;Fred&quot;);
    frog1.Weight_value(55);
    frog1.Color_value(&quot;Green&quot;);
    context.Post(frog1);

    XYZ_Frog_Class frog2;
    frog2.Name_value(&quot;Sam&quot;);
    frog2.Weight_value(65);
    frog2.Color_value(&quot;Blue&quot;);
    context.Post(frog2);

    context.Post(MI_RESULT_OK);
}
</pre></div>

<table class="cartouche" border="1"><tr><td>
<p><b>Note:</b> In CIM, a property either has a value or is null (has no value). The
&lsquo;<samp>XYZ_Frog.Name_exists</samp>&rsquo; function returns true if the &lsquo;<samp>Frog.Name</samp>&rsquo;
property has a value or false if the property is null (has no value). If the
property has a value, one may call the &lsquo;<samp>XYZ_Frog.Name_value</samp>&rsquo; function
to obtain it.
</p></td></tr></table>

<a name="Registering-the-provider"></a>
<h3 class="section">7.4 Registering the provider</h3>

<p>Next we register the provider as follows:
</p>
<div class="example">
<pre class="verbatim"># make reg
/opt/omi/bin/omireg libfrog.so
Copied provider to /opt/omi/lib/libfrog.so
Created /opt/omi/etc/omiregister/root-cimv2/frog.reg
</pre></div>

<p>This creates &lsquo;<samp>frog.reg</samp>&rsquo; under the registration directory for the default
namespace &lsquo;<samp>root/cimv2</samp>&rsquo; and it copies the provider to the installed
directory.
</p>
<a name="Testing-the-provider"></a>
<h3 class="section">7.5 Testing the provider</h3>

<p>To test the provider, send an enumerate request to the provider as shown below.
</p>
<div class="example">
<pre class="verbatim"># omicli ei root/cimv2 XYZ_Frog
instance of XYZ_Frog
{
    [Key] Name=Fred
    Weight=55
    Color=Green
}
instance of XYZ_Frog
{
    [Key] Name=Sam
    Weight=65
    Color=Blue
}
</pre></div>

<a name="Going-further"></a>
<h3 class="section">7.6 Going further</h3>

<p>While this chapter has given a brief overview of the provider development process, 
the next chapter goes into provider development in more detail.
</p>
<a name="Developing-providers"></a>
<h2 class="chapter">8 Developing providers</h2>

<p>This chapter shows how to develop providers, a process consisting of 6 stages:
</p>
<ul>
<li> Defining the MOF schema
</li><li> Generating the provider sources
</li><li> Implementing the provider operations
</li><li> Building the provider
</li><li> Registering the provider
</li><li> Validating the provider
</li></ul>

<p>We discuss each stage, showing how to develop providers that implement the
following operations:
</p>
<ul>
<li> <strong>get-instance</strong>
</li><li> <strong>enumerate-instances</strong>
</li><li> <strong>associator-names</strong>
</li><li> <strong>reference-names</strong>
</li><li> <strong>invoke-method</strong>
</li></ul>

<p>OMI supports two provider language bindings: C and C++. This chapter
only shows how to use the C++ binding. Whether you build C or C++ providers,
the development stages are the same although the details of the interface vary.
For more information about the C interface, see the &lsquo;<samp>&lt;MI/MI.h&gt;</samp>&rsquo; header
file and experiment with generating C providers.
</p>
<a name="Defining-the-MOF-schema"></a>
<h3 class="section">8.1 Defining the MOF schema</h3>

<p>The first stage is to define the MOF classes comprising your schema. You may
extend an existing CIM class like this:
</p>
<div class="example">
<pre class="verbatim">class XYZ_MyComputerSystem : CIM_ComputerSystem
{
    ...
};
</pre></div>

<p>Or you may define a new root class (with no super class):
</p>
<div class="example">
<pre class="verbatim">class MyClass
{
    ...
};
</pre></div>

<p>The MOF language is defined in the <b>CIM Infrastructure Specification
(DSP0004)</b>, which may be found at (<a href="http://dmtf.org/standards/cim">http://dmtf.org/standards/cim</a>).
</p>
<p>The provider developed below implements the following class definitions (which
are placed in a file called &lsquo;<samp>schema.mof</samp>&rsquo;).
</p>
<div class="example">
<pre class="verbatim">// schema.mof

class XYZ_Widget
{
    [Key] Uint32 Key;
    Uint32 ModelNumber;
    String Color;
};

class XYZ_Gadget
{
    [Key] Uint32 Key;
    Uint32 ModelNumber;
    Uint32 Size;

    Uint32 ChangeState(
        [In] Uint32 NewState,
        [In(False), Out] Uint32 OldState);
};

[Association]
class XYZ_Connector
{
    [Key] XYZ_Widget REF Left;
    [Key] XYZ_Gadget REF Right;
};
</pre></div>

<p>Notice that all classes define above have the &lsquo;<samp>XYZ_</samp>&rsquo; prefix. Similarly,
all classes in the CIM schema begin have the &lsquo;<samp>CIM_</samp>&rsquo; prefix. All classes
should have a suitable prefix but for brevity, this prefix is omitted
henceforth.
</p>
<p>The &lsquo;<samp>Connector</samp>&rsquo; class is an association, as indicated by the
&lsquo;<samp>Associator</samp>&rsquo; qualifier. Each instance of &lsquo;<samp>Connector</samp>&rsquo;, connects
one instance of &lsquo;<samp>Widget</samp>&rsquo; with one instance of &lsquo;<samp>Gadget</samp>&rsquo;.
</p>
<a name="Generating-the-provider-sources-1"></a>
<h3 class="section">8.2 Generating the provider sources</h3>

<p>The second stage involves generating the provider sources. The following
command generates provider sources from the &lsquo;<samp>schema.mof</samp>&rsquo; file defined
above.
</p>
<div class="example">
<pre class="example">omigen --cpp -m xyzconnector schema.mof \
   XYZ_Gadget=Gadget XYZ_Widget=Widget XYZ_Connector=Connector
Creating Gadget.h
Creating Gadget_Class_Provider.h
Creating Gadget_Class_Provider.cpp
Creating Widget.h
Creating Widget_Class_Provider.h
Creating Widget_Class_Provider.cpp
Creating Connector.h
Creating Connector_Class_Provider.h
Creating Connector_Class_Provider.cpp
Creating schema.c
Creating stubs.cpp
Creating module.cpp
Creating module.h
Creating GNUmakefile
</pre></div>

<p>The &lsquo;<samp>--cpp</samp>&rsquo; option creates &lsquo;<samp>C++</samp>&rsquo; sources (instead of C sources by
default). The &lsquo;<samp>-m xyzconnector</samp>&rsquo; option creates &lsquo;<samp>GNUmakefile</samp>&rsquo; with
rules for building, regenerating, and registering the provider. This makefile
creates a library whose base name is given by the &lsquo;<samp>-m</samp>&rsquo; option
(&lsquo;<samp>xyzconnector</samp>&rsquo;).
</p>
<table class="cartouche" border="1"><tr><td>
<p><b>Tip:</b> You may regenerate sources by typing &lsquo;<samp>make gen</samp>&rsquo; or by retyping the
command above. The generator will never overwrite editable files. Instead it
attempts to patch them. Some files are non-editable and are regenerated
completely.
</p></td></tr></table>

<p>The generator creates sources for classes &lsquo;<samp>XYZ_Gadget</samp>&rsquo;, &lsquo;<samp>XYZ_Widget</samp>&rsquo;,
and &lsquo;<samp>XYZ_Connector</samp>&rsquo;. The command above defines aliases for each class name,
allowing shorter names to be used throughout the source code. For example,
&lsquo;<samp>XYZ_Gadget=Gadget</samp>&rsquo; causes &lsquo;<samp>Gadget.h</samp>&rsquo; to be generated instead of
&lsquo;<samp>XYZ_Gadget.h</samp>&rsquo;. Alias can be used to completely rename a class. For
example: &lsquo;<samp>CIM_ComputerSystem=CompSys</samp>&rsquo;.
</p>
<p>To learn more about the &lsquo;<samp>omigen</samp>&rsquo; options, type &lsquo;<samp>omigen -h</samp>&rsquo; to print
a help message.
</p>
<p>The purpose of each generated file is given below.
</p>
<ul>
<li> <code>Gadget.h</code> &ndash; defines C++ class for the CIM <code>Gadget</code> class.
</li><li> <code>Widget.h</code> &ndash; defines C++ class for the CIM <code>Widget</code> class.
</li><li> <code>Connector.h</code> &ndash; defines C++ class for the CIM <code>Connector</code> class.
</li><li> <code>Gadget_Class_Provider.h</code> &ndash; defines <code>Gadget_Class_Provider</code> class.
</li><li> <code>Gadget_Class_Provider.cpp</code> &ndash; defines <code>Gadget_Class_Provider</code> class.
</li><li> <code>Widget_Class_Provider.h</code> &ndash; defines <code>Widget_Class_Provider</code> class.
</li><li> <code>Widget_Class_Provider.cpp</code> &ndash; defines <code>Widget_Class_Provider</code> class.
</li><li> <code>Connector_Class_Provider.h</code> &ndash; defines <code>Connector_Class_Provider</code> class.
</li><li> <code>Connector_Class_Provider.cpp</code> &ndash; defines <code>Connector_Class_Provider</code> class.
</li><li> <code>schema.c</code> &ndash; internal definitions.
</li><li> <code>stubs.cpp</code> &ndash; internal definitions.
</li><li> <code>module.cpp</code> &ndash; defines &lsquo;<samp>MI_Main</samp>&rsquo; library entry point.
</li><li> <code>module.h</code> &ndash; defines &lsquo;<samp>Module</samp>&rsquo; class.
</li><li> <code>GNUmakefile</code> &ndash; defines rules for building the provider library.
</li></ul>

<p>Many of these files are not intended to be edited. Developer edits may be made
to the following files.
</p>
<ul>
<li> <code>Gadget_Class_Provider.h</code>
</li><li> <code>Gadget_Class_Provider.cpp</code>
</li><li> <code>Widget_Class_Provider.h</code>
</li><li> <code>Widget_Class_Provider.cpp</code>
</li><li> <code>Connector_Class_Provider.h</code>
</li><li> <code>Connector_Class_Provider.cpp</code>
</li><li> <code>module.h</code>
</li><li> <code>module.cpp</code>
</li></ul>

<p>For example, to implement the &lsquo;<samp>get-instances</samp>&rsquo; operation for the
&lsquo;<samp>Gadget</samp>&rsquo; class, modify the &lsquo;<samp>Gadget_Class_Provider.cpp</samp>&rsquo; file.
</p>
<a name="Implementing-the-provider-operations"></a>
<h3 class="section">8.3 Implementing the provider operations</h3>

<p>This section shows how to implement the following provider operations:
</p>
<ul>
<li> <strong>get-instance</strong>
</li><li> <strong>enumerate-instances</strong>
</li><li> <strong>associator-names</strong>
</li><li> <strong>reference-names</strong>
</li><li> <strong>invoke-method</strong>
</li></ul>

<a name="Implementing-enumerate_002dinstances"></a>
<h4 class="subsection">8.3.1 Implementing enumerate-instances</h4>

<p>This section implement the enumerate-instances operation for the <code>Gadget</code>
class. This implementation provides the following instances (shown in MOF
format).
</p>
<div class="example">
<pre class="verbatim">instance of XYZ_Gadget
{
    Key = 1003;
    ModelNumber = 3;
    Size = 33;
};

instance of XYZ_Gadget
{
    Key = 1004;
    ModelNumber = 4;
    Size = 43;
};
</pre></div>

<p>To implement the enumerate-instance operation for the <code>Gadget</code> class,
start by examining the generated stub (see &lsquo;<samp>Gadget_Class_Provider.cpp</samp>&rsquo;).
</p>
<div class="example">
<pre class="verbatim">void Gadget_Class_Provider::EnumerateInstances(
    Context&amp; context,
    const String&amp; nameSpace,
    const PropertySet&amp; propertySet,
    bool keysOnly,
    const MI_Filter* filter)
{
    context.Post(MI_RESULT_NOT_SUPPORTED);
}
</pre></div>

<p>This function is invoked by the CIM server. The implementer may respond on
the same thread or he may create a new thread if the request is long
running. The lifetime of the request is bound to the lifetime of the
&lsquo;<samp>context</samp>&rsquo; parameter. All parameters remain in scope until the provider
calls &lsquo;<samp>Context::Post</samp>&rsquo;. The provider may create a new thread to
handle the request, in which case the parameters may live beyond the invocation
of &lsquo;<samp>EnumerateInstances</samp>&rsquo;.
</p>
<p>We provide an implementation that provides two instances of the &lsquo;<samp>Gadget</samp>&rsquo;
class. The following implementation handles the request on the calling thread.
</p>
<div class="example">
<pre class="verbatim">void Gadget_Class_Provider::EnumerateInstances(
    Context&amp; context,
    const String&amp; nameSpace,
    const PropertySet&amp; propertySet,
    bool keysOnly,
    const MI_Filter* filter)
{
    // Gadget.Key=1003:
    {
        Gadget_Class g;
        g.Key_value(1003);
        g.ModelNumber_value(3);
        g.Size_value(33);
        context.Post(g);
    }

    // Gadget.Key=1004:
    {
        Gadget_Class g;
        g.Key_value(1004);
        g.ModelNumber_value(4);
        g.Size_value(43);
        context.Post(g);
    }

    context.Post(MI_RESULT_OK);
}
</pre></div>

<p>This function constructs instances of the &lsquo;<samp>Gadget</samp>&rsquo; class and passes them to
the &lsquo;<samp>Context::Post</samp>&rsquo; function. When all instances have been posted, the
provider passes the result status to the &lsquo;<samp>Context::Post</samp>&rsquo; function. This
finalizes the request.
</p>
<table class="cartouche" border="1"><tr><td>
<p><b>Tip:</b> By passing the &lsquo;<samp>--nogi CLASSNAME</samp>&rsquo; option (no get-instance) to the
generator tool, the server uses the &lsquo;<samp>enumerate-instances</samp>&rsquo; implementation
to satisfy all &lsquo;<samp>get-instance</samp>&rsquo; requests. Only use this technique if the
number of instances is small, otherwise the provider will be very slow.
</p></td></tr></table>

<a name="Implementing-get_002dinstance"></a>
<h4 class="subsection">8.3.2 Implementing get-instance</h4>

<p>Next we show how to implement the <code>get-instance</code> operation for the
<code>Gadget</code> class. Here is the generated stub for the <code>get-instance</code>
request.
</p>
<div class="example">
<pre class="verbatim">void Gadget_Class_Provider::GetInstance(
    Context&amp; context,
    const String&amp; nameSpace,
    const Gadget_Class&amp; instanceName,
    const PropertySet&amp; propertySet)
{
    context.Post(MI_RESULT_NOT_SUPPORTED);
}
</pre></div>

<p>The <code>instanceName</code> parameter holds the keys for the target instance.
Here is the full implementation of this function.
</p>
<div class="example">
<pre class="verbatim">void Gadget_Class_Provider::GetInstance(
    Context&amp; context,
    const String&amp; nameSpace,
    const Gadget_Class&amp; instanceName,
    const PropertySet&amp; propertySet)
{
    if (instanceName.Key_value() == 1003)
    {
        // Gadget.Key=1003:
        Gadget_Class g;
        g.Key_value(1003);
        g.ModelNumber_value(3);
        g.Size_value(33);
        context.Post(g);
        context.Post(MI_RESULT_OK);
    }
    else if (instanceName.Key_value() == 1004)
    {
        // Gadget.Key=1004:
        Gadget_Class g;
        g.Key_value(1004);
        g.ModelNumber_value(4);
        g.Size_value(43);
        context.Post(g);
        context.Post(MI_RESULT_OK);
    }
    else
    {
        context.Post(MI_RESULT_NOT_FOUND);
    }
}
</pre></div>

<p>We examine the key and return the matching instance. If neither condition
matches, we post the &lsquo;<samp>MI_RESULT_NOT_FOUND</samp>&rsquo; result.
</p>
<a name="Implementing-an-extrinsic-method"></a>
<h4 class="subsection">8.3.3 Implementing an extrinsic method</h4>

<p>This section implements the &lsquo;<samp>ChangeState</samp>&rsquo; extrinsic method. The generator
produces the following stub.
</p>
<div class="example">
<pre class="verbatim">void Gadget_Class_Provider::Invoke_ChangeState(
    Context&amp; context,
    const String&amp; nameSpace,
    const Gadget_Class&amp; instanceName,
    const Gadget_ChangeState_Class&amp; in)
{
    context.Post(MI_RESULT_NOT_SUPPORTED);
}
</pre></div>

<p>The &lsquo;<samp>instanceName</samp>&rsquo; parameter is the instance whose &lsquo;<samp>ChangeState</samp>&rsquo;
method has been invoked (this parameter is omitted for static methods). The
&lsquo;<samp>in</samp>&rsquo; parameter contains the input parameters. The implementation should
perform the following tasks:
</p>
<ul>
<li> Read the input parameters.
</li><li> Perform the desired action.
</li><li> Build the output parameters.
</li><li> Set the return value.
</li><li> Post the output parameters to the server.
</li><li> Return a successful status.
</li></ul>

<p>The following implementation performs each of these steps.
</p>
<div class="example">
<pre class="verbatim">void Gadget_Class_Provider::Invoke_ChangeState(
    Context&amp; context,
    const String&amp; nameSpace,
    const Gadget_Class&amp; instanceName,
    const Gadget_ChangeState_Class&amp; in)
{
    Gadget_ChangeState_Class out;

    // Print the input parameter:
    if (in.NewState_exists())
    {
        printf(&quot;NewState=%u\n&quot;, in.NewState_value());
    }

    // Perform desired action here:
    ...

    // Set the output parameter:
    out.OldState_value(2);

    // Set the return value:
    out.MIReturn_value(0);

    // Post the &quot;out&quot; object.
    context.Post(out);

    // Post the result status.
    context.Post(MI_RESULT_OK);
}
</pre></div>

<a name="Implementing-enumerate_002dinstances-for-an-association-provider"></a>
<h4 class="subsection">8.3.4 Implementing enumerate-instances for an association provider</h4>

<p>This section shows how to implement the enumerate-instances operation for the
&lsquo;<samp>Connector</samp>&rsquo; association class. This operation produces the following
instances (shown in MOF format).
</p>
<div class="example">
<pre class="verbatim">instance of XYZ_Connector
{
    Left = &quot;XYZ_Widget.Key=1001&quot;;
    Right = &quot;XYZ_Gadget.Key=1003&quot;;
};

instance of XYZ_Connector
{
    Left = &quot;XYZ_Widget.Key=1002&quot;;
    Right = &quot;XYZ_Gadget.Key=1004&quot;;
};
</pre></div>

<p>Here is the implementation.
</p>
<div class="example">
<pre class="verbatim">void Connector_Class_Provider::EnumerateInstances(
    Context&amp; context,
    const String&amp; nameSpace,
    const PropertySet&amp; propertySet,
    bool keysOnly,
    const MI_Filter* filter)
{
    // Connector.Left=&quot;Gadget.Key=1001&quot;,&quot;Widget.Key=1003&quot;
    {
        Widget_Class w;
        w.Key_value(1001);
        Gadget_Class g;
        g.Key_value(1003);
        Connector_Class c;
        c.Left_value(w);
        c.Right_value(g);
        context.Post(c);
    }

    // Connector.Left=&quot;Gadget.Key=1002&quot;,&quot;Widget.Key=1004&quot;
    {
        Widget_Class w;
        w.Key_value(1002);
        Gadget_Class g;
        g.Key_value(1004);
        Connector_Class c;
        c.Left_value(w);
        c.Right_value(g);
        context.Post(c);
    }

    context.Post(MI_RESULT_OK);
}
</pre></div>

<a name="Implementing-get_002dinstances-for-an-association-class"></a>
<h4 class="subsection">8.3.5 Implementing get-instances for an association class</h4>

<p>The following example implements &lsquo;<samp>get-instance</samp>&rsquo; for the &lsquo;<samp>Connector</samp>&rsquo;
association class.
</p>
<div class="example">
<pre class="verbatim">void Connector_Class_Provider::GetInstance(
    Context&amp; context,
    const String&amp; nameSpace,
    const Connector_Class&amp; instanceName,
    const PropertySet&amp; propertySet)
{
    if (instanceName.Left_value().Key_value() == 1001 &amp;&amp;
        instanceName.Right_value().Key_value() == 1003)
    {
        // Connector.Left=&quot;Gadget.Key=1001&quot;,&quot;Widget.Key=1003&quot;
        Widget_Class w;
        w.Key_value(1001);

        Gadget_Class g;
        g.Key_value(1003);

        Connector_Class c;
        c.Left_value(w);
        c.Right_value(g);

        context.Post(c);
        context.Post(MI_RESULT_OK);
    }
    else if (instanceName.Left_value().Key_value() == 1002 &amp;&amp;
        instanceName.Right_value().Key_value() == 1004)
    {
        // Connector.Left=&quot;Gadget.Key=1002&quot;,&quot;Widget.Key=1004&quot;
        Widget_Class w;
        w.Key_value(1001);

        Gadget_Class g;
        g.Key_value(1003);

        Connector_Class c;
        c.Left_value(w);
        c.Right_value(g);

        context.Post(c);
        context.Post(MI_RESULT_OK);
    }
    else
    {
        context.Post(MI_RESULT_NOT_FOUND);
    }
}
</pre></div>

<p>Note that <code>instanceName.Left_value()</code> returns an instance of type
<code>Gadget</code> (see MOF definitions). And so
<code>instanceName.Left_value().Key_value()</code> returns the &lsquo;<samp>Key</samp>&rsquo; property
of the associated <code>Gadget</code> instance.
</p>
<a name="Implementing-the-associator_002dinstances-operation"></a>
<h4 class="subsection">8.3.6 Implementing the associator-instances operation</h4>

<p>This section shows how to implement the associator-instances operation. This
operation finds the other end of an association. For example, it might find
the <code>Gadget</code> instances that are associated with a single <code>Widget</code>
instance (through a <code>Connector</code> instance). For example, consider the
following MOF definitions.
</p>
<div class="example">
<pre class="verbatim">instance of XYZ_Connector
{
    Left  = &quot;XYZ_Widget.Key=1001&quot;;
    Right = &quot;XYZ_Gadget.Key=1003&quot;;
};

instance of XYZ_Connector
{
    Left  = &quot;XYZ_Widget.Key=1002&quot;;
    Right = &quot;XYZ_Gadget.Key=1004&quot;;
};
</pre></div>

<p>The associator-instances operation starts with the instance name of an
instance and finds associated instances. For example, the associator-instances
of:
</p>
<div class="example">
<pre class="example">XYZ_Widget.Key=1001
</pre></div>

<p>include:
</p>
<div class="example">
<pre class="example">XYZ_Gadget.Key=1003
</pre></div>

<p>The generator produces two stubs to handle associator-instances requests.
The first yields associators in which the <code>instanceName</code> parameter matches
the first reference property (<code>Connector.Left</code>). The second yields
associations in which the <code>instanceName</code> parameter matches the second
reference property (<code>Connector.Right</code>). The stubs are defined as follows.
</p>
<div class="example">
<pre class="verbatim">void Connector_Class_Provider::AssociatorInstancesLeft(
    Context&amp; context,
    const String&amp; nameSpace,
    const Widget_Class&amp; instanceName,
    const String&amp; resultClass,
    const PropertySet&amp; propertySet,
    bool keysOnly,
    const MI_Filter* filter)
{
    context.Post(MI_RESULT_NOT_SUPPORTED);
}

void Connector_Class_Provider::AssociatorInstancesRight(
    Context&amp; context,
    const String&amp; nameSpace,
    const Gadget_Class&amp; instanceName,
    const String&amp; resultClass,
    const PropertySet&amp; propertySet,
    bool keysOnly,
    const MI_Filter* filter)
{
    context.Post(MI_RESULT_NOT_SUPPORTED);
}
</pre></div>

<p>The following implementation yields associators of <code>Widget</code> instances.
</p>
<div class="example">
<pre class="verbatim">void Connector_Class_Provider::AssociatorInstancesLeft(
    Context&amp; context,
    const String&amp; nameSpace,
    const Widget_Class&amp; instanceName,
    const String&amp; resultClass,
    const PropertySet&amp; propertySet,
    bool keysOnly,
    const MI_Filter* filter)
{
    if (instanceName.Key_value() == 1001)
    {
        // Gadget.Key=1003:
        Gadget_Class g;
        g.Key_value(1003);
        g.ModelNumber_value(3);
        g.Size_value(33);
        context.Post(g);
        context.Post(MI_RESULT_OK);
    }
    else if (instanceName.Key_value() == 1002)
    {
        // Gadget.Key=1004:
        Gadget_Class g;
        g.Key_value(1004);
        g.ModelNumber_value(4);
        g.Size_value(43);
        context.Post(g);
        context.Post(MI_RESULT_OK);
    }
    else
    {
        context.Post(MI_RESULT_NOT_FOUND);
    }
}
</pre></div>


<a name="Implementing-the-reference_002dinstances-operation"></a>
<h4 class="subsection">8.3.7 Implementing the reference-instances operation</h4>

<p>The reference-instances operation takes an instance name and finds the
reference instances that refer to it. Consider the following MOF definitions.
</p>
<div class="example">
<pre class="verbatim">instance of XYZ_Connector
{
    Left  = &quot;XYZ_Widget.Key=1001&quot;;
    Right = &quot;XYZ_Gadget.Key=1003&quot;;
};

instance of XYZ_Connector
{
    Left  = &quot;XYZ_Widget.Key=1002&quot;;
    Right = &quot;XYZ_Gadget.Key=1004&quot;;
};
</pre></div>

<p>For example, the reference-instance of <code>XYZ_Widget.Key=1001</code> includes the
first MOF instance shown above. As with associator-instances, the generator
produces two stubs:
</p>
<div class="example">
<pre class="verbatim">void Connector_Class_Provider::ReferenceInstancesLeft(
    Context&amp; context,
    const String&amp; nameSpace,
    const Widget_Class&amp; instanceName,
    const PropertySet&amp; propertySet,
    bool keysOnly,
    const MI_Filter* filter)
{
    context.Post(MI_RESULT_NOT_SUPPORTED);
}

void Connector_Class_Provider::ReferenceInstancesRight(
    Context&amp; context,
    const String&amp; nameSpace,
    const Gadget_Class&amp; instanceName,
    const PropertySet&amp; propertySet,
    bool keysOnly,
    const MI_Filter* filter)
{
    context.Post(MI_RESULT_NOT_SUPPORTED);
}
</pre></div>

<p>The implementation of <code>ReferenceInstancesLeft</code> is shown below.
</p>
<div class="example">
<pre class="verbatim">void Connector_Class_Provider::ReferenceInstancesLeft(
    Context&amp; context,
    const String&amp; nameSpace,
    const Widget_Class&amp; instanceName,
    const PropertySet&amp; propertySet,
    bool keysOnly,
    const MI_Filter* filter)
{
    if (instanceName.Key_value() == 1001)
    {
        // Connector.Left=&quot;Gadget.Key=1001&quot;,&quot;Widget.Key=1003&quot;
        Widget_Class w;
        w.Key_value(1001);
        Gadget_Class g;
        g.Key_value(1003);
        Connector_Class c;
        c.Left_value(w);
        c.Right_value(g);
        context.Post(c);
        context.Post(MI_RESULT_OK);
    }
    else if (instanceName.Key_value() == 1002)
    {
        // Connector.Left=&quot;Gadget.Key=1002&quot;,&quot;Widget.Key=1004&quot;
        Widget_Class w;
        w.Key_value(1002);
        Gadget_Class g;
        g.Key_value(1004);
        Connector_Class c;
        c.Left_value(w);
        c.Right_value(g);
        context.Post(c);
        context.Post(MI_RESULT_OK);
    }
    else
    {
        context.Post(MI_RESULT_NOT_FOUND);
    }
}
</pre></div>


<a name="Implementing-indication-operations-_0028experimental_0029"></a>
<h4 class="subsection">8.3.8 Implementing indication operations (<em>experimental</em>)</h4>

<p>Please note that indications should only be posted from a separate 
thread within the provider (a âbackground threadâ). They should not 
be posted using the &lsquo;<samp>omiserver</samp>&rsquo; thread during a call into a 
provider. For example, during an &lsquo;<samp>EnumerateInstances</samp>&rsquo; call, the 
provider should directly post its instances and final result. It should 
not directly post indications within that function call. Instead, it 
should post indications on a separate background thread. Violation of 
this policy may trigger unexpected behavior in &lsquo;<samp>omiserver</samp>&rsquo;. The 
following examples illustrate appropriate techniques for posting alert 
and lifecycle indications. 
</p>
<a name="Implementing-an-alert-indication-_0028experimental_0029"></a>
<h4 class="subsubsection">8.3.8.1 Implementing an alert indication (<em>experimental</em>)</h4>

<p>As an example, consider the following MOF schema:
</p>
<div class="example">
<pre class="verbatim">/* Indication class derived from the CIM standard indication class */
class XYZ_DiskFault : CIM_Indication
{
  string detailmessage;
};
</pre></div>

<p>The generated code snippet looks like this:
</p>
<div class="example">
<pre class="verbatim">void MI_CALL XYZ_DiskFault_EnableIndications(
        XYZ_DiskFault_Self* self,
        MI_Context* indicationsContext,
        const MI_Char* nameSpace,
        const MI_Char* className )
{
  /* TODO: store indicationsContext for posting indication usage */
  /* NOTE: Call one of following functions if and ONLY if a termination
           error occurs, to finalize the indicationsContext, 
           and terminate all active subscriptions to current class:

             MI_Context_PostResult
             MI_Context_PostError
             MI_Context_PostCimError      */
}

void MI_CALL XYZ_DiskFault_DisableIndications(
        XYZ_DiskFault_Self* self,
        MI_Context* indicationsContext,
        const MI_Char* nameSpace,
        const MI_Char* className )
{
  /* TODO: stop background thread that monitors subscriptions */
  MI_PostResult( indicationsContext, MI_RESULT_OK );
}

void MI_CALL XYZ_DiskFault_Subscribe(
        XYZ_DiskFault_Self* self,
        MI_Context* context,
        const MI_Char* nameSpace,
        const MI_Char* className,
        const MI_Filter* filter,
        const MI_Char* bookmark,
        MI_Uint64  subscriptionID,
        void** subscriptionSelf )
{
  /* NOTE: This function indicates that a new subscription occurred */
}

void MI_CALL XYZ_DiskFault_Unsubscribe(
        XYZ_DiskFault_Self* self,
        MI_Context* context,
        const MI_Char* nameSpace,
        const MI_Char* className,
        MI_Uint64  subscriptionID,
        void* subscriptionSelf )
{
  /* NOTE: This function indicates that a subscription was cancelled */
  MI_PostResult( context, MI_RESULT_OK );
}
</pre></div>

<p>The implementation of this indication class is shown below (see the sample code
in the &lsquo;<samp>Indication/Alert</samp>&rsquo; subdirectory under the samples directory for the 
complete implementation):
</p>
<div class="example">
<pre class="verbatim">void MI_CALL XYZ_DiskFault_EnableIndications(
        XYZ_DiskFault_Self* self,
        MI_Context* indicationsContext,
        const MI_Char* nameSpace,
        const MI_Char* className )
{
  /* TODO: store indicationsContext for posting indication usage */
  /* NOTE: Call one of following functions if and ONLY if a termination
           error occurs, to finalize the indicationsContext, 
           and terminate all active subscriptions to current class:

             MI_Context_PostResult
             MI_Context_PostError
             MI_Context_PostCimError      */

  int code;
  memset( self, 0, sizeof(XYZ_DiskFault_Self) );
  self-&gt;self.context = indicationsContext;
  self-&gt;self.postindication = TriggerIndication;
  code = Thread_Create(&amp;self-&gt;self.thread, fireIndication, (void*)self);
  if ( code != 0 )
  {
    /* Failed to create thread */
    MI_Context_PostError( indicationsContext, MI_RESULT_FAILED, 
                          MI_T(&quot;MI&quot;), MI_T(&quot;Failed to create thread&quot;) );
  }
}

void MI_CALL XYZ_DiskFault_DisableIndications(
        XYZ_DiskFault_Self* self,
        MI_Context* indicationsContext,
        const MI_Char* nameSpace,
        const MI_Char* className )
{
  /* TODO: stop background thread that monitors subscriptions */
  MI_Uint32 retValue;
  self-&gt;self.disabling = MI_TRUE;
  Thread_Join( &amp; self-&gt;self.thread, &amp;retValue );
  MI_PostResult( indicationsContext, MI_RESULT_OK );
}
</pre></div>

<a name="Implementing-a-lifecycle-indication-_0028experimental_0029"></a>
<h4 class="subsubsection">8.3.8.2 Implementing a lifecycle indication (<em>experimental</em>)</h4>

<p>This section describes how to implement lifecycle indication support in a 
normal class.
</p>
<p>Consider a common process class as an example:
</p>
<div class="example">
<pre class="verbatim">/* A class derived from CIM_Process */
class XYZ_Process : CIM_Process
{
  uint32 runningTime;
  
  [static]
  uint32 Create( [in] string imageName, [out] CIM_Process REF process );
  uint32 GetRunTime( [in] uint32 pid, [out] uint32 runningTime );
};
</pre></div>

<p>The generated code snippet looks like this:
</p>
<div class="example">
<pre class="verbatim">void MI_CALL XYZ_Process_EnumerateInstances(
        XYZ_Process_Self* self,
        MI_Context* context,
        const MI_Char* nameSpace,
        const MI_Char* className,
        const MI_PropertySet* propertySet,
        MI_Boolean keysOnly,
        const MI_Filter* filter )
{
  MI_PostResult( context, MI_RESULT_NOT_SUPPORTED );
}

void MI_CALL XYZ_Process_GetInstance(
        XYZ_Process_Self* self,
        MI_Context* context,
        const MI_Char* nameSpace,
        const MI_Char* className,
        const XYZ_Process* instanceName,
        const MI_PropertySet* propertySet )
{
  MI_PostResult( context, MI_RESULT_NOT_SUPPORTED );
}

void MI_CALL XYZ_Process_CreateInstance(
        XYZ_Process_Self* self,
        MI_Context* context,
        const MI_Char* nameSpace,
        const MI_Char* className,
        const XYZ_Process* newInstance )
{
  MI_PostResult( context, MI_RESULT_NOT_SUPPORTED );
}

void MI_CALL XYZ_Process_ModifyInstance(
        XYZ_Process_Self* self,
        MI_Context* context,
        const MI_Char* nameSpace,
        const MI_Char* className,
        const XYZ_Process* modifiedInstance,
        const MI_PropertySet* propertySet )
{
  MI_PostResult( context, MI_RESULT_NOT_SUPPORTED );
}

void MI_CALL XYZ_Process_DeleteInstance(
        XYZ_Process_Self* self,
        MI_Context* context,
        const MI_Char* nameSpace,
        const MI_Char* className,
        const XYZ_Process* instanceName )
{
  MI_PostResult( context, MI_RESULT_NOT_SUPPORTED );
}

void MI_CALL XYZ_Process_Invoke_RequestStateChange(
        XYZ_Process_Self* self,
        MI_Context* context,
        const MI_Char* nameSpace,
        const MI_Char* className,
        const MI_Char* methodName,
        const XYZ_Process* instanceName,
        const XYZ_Process_RequestStateChange* in )
{
  MI_PostResult( context, MI_RESULT_NOT_SUPPORTED );
}

void MI_CALL XYZ_Process_Invoke_Create(
        XYZ_Process_Self* self,
        MI_Context* context,
        const MI_Char* nameSpace,
        const MI_Char* className,
        const MI_Char* methodName,
        const XYZ_Process* instanceName,
        const XYZ_Process_Create* in )
{
  MI_PostResult( context, MI_RESULT_NOT_SUPPORTED );
}

void MI_CALL XYZ_Process_Invoke_GetRunTime(
        XYZ_Process_Self* self,
        MI_Context* context,
        const MI_Char* nameSpace,
        const MI_Char* className,
        const MI_Char* methodName,
        const XYZ_Process* instanceName,
        const XYZ_Process_GetRunTime* in )
{
    MI_PostResult( context, MI_RESULT_NOT_SUPPORTED );
}
</pre></div>

<p>Implementation of lifecycle indications within this class takes a form like
the following:
</p>
<div class="example">
<pre class="verbatim">void MI_CALL XYZ_Process_Load(
        XYZ_Process_Self** self,
        MI_Module_Self* selfModule,
        MI_Context* context )
{
  MI_Result r;
  *self = &amp;g_self;
  memset(&amp;g_self, 0, sizeof(g_self));

  /* get lifecycle context and store the context for 
   * posting indication usage */
  r = MI_Context_GetLifecycleIndicationContext(
      context, &amp;(*self)-&gt;context);
  CHECKR_POST_RETURN_VOID(context, r);

  /* register a callback, which will be invoked if subscription
   * changed, i.e., client cancelled a subscription or create a new
   * subscription */
  r = MI_LifecycleIndicationContext_RegisterCallback(
      (*self)-&gt;context, _LifecycleIndicationCallback,
      (void*)(ptrdiff_t)(*self));
  CHECKR_POST_RETURN_VOID(context, r);

  /* notify server that what types of lifecycle indication
   * supported by current class */
  r = MI_LifecycleIndicationContext_SetSupportedTypes(
      (*self)-&gt;context, MI_LIFECYCLE_INDICATION_CREATE);
  CHECKR_POST_RETURN_VOID(context, r);

  /* initialize global data */
  r = _Initialize(context, *self);
  if (r != MI_RESULT_OK)
  {
    _Finalize(*self);
    *self = NULL;
  }
  else
  {
    int code;
    (*self)-&gt;self.context = (*self)-&gt;context;
    (*self)-&gt;self.postindication = TriggerIndication;
    
    /*
     * Please note that lifecycle indications should only be posted
     * from a background thread.
     *
     * This XYZ_Process example spawns a background thread that will
     * periodically fire CIM_InstCreation indications to simulate
     * process creation events.
     */
    code = Thread_Create(&amp;(*self)-&gt;self.thread, fireIndication,
        (void*)(*self));
    if ( code != 0 )
    {
        /* Failed to create thread */
        r = MI_RESULT_FAILED;
        _Finalize(*self);
    }
  }
  MI_PostResult(context, r); *self = &amp;g_self;
}

void MI_CALL XYZ_Process_Unload(
        XYZ_Process_Self* self,
        MI_Context* context)
{
  MI_Uint32 retValue;

  /* Shutdown the spawned thread */
  self-&gt;self.disabling = MI_TRUE;
  Thread_Join( &amp; self-&gt;self.thread, &amp;retValue );

  /* cleanup */
  _Finalize( self );
  MI_LifecycleIndicationContext_PostResult(self-&gt;context,MI_RESULT_OK);
  MI_PostResult( context, MI_RESULT_OK );       _Finalize(self);
}

void MI_CALL XYZ_Process_EnumerateInstances(
        XYZ_Process_Self* self,
        MI_Context* context,
        const MI_Char* nameSpace,
        const MI_Char* className,
        const MI_PropertySet* propertySet,
        MI_Boolean keysOnly,
        const MI_Filter* filter )
{
  MI_Uint32 i;
  MI_Result r;
  for( i = 0; i &lt; PROCESS_COUNT; i++ )
  {
    r = XYZ_Process_Post( &amp;self-&gt;processes[i], context );
    if( r != MI_RESULT_OK )
      break;
  }
  MI_PostResult( context, r );
}

/*
 * Callback function to trigger lifecycle indication (CIM_InstCreation)
 * for XYZ_Process.
 * This function simulates the process creation events by posting a
 * CIM_InstCreation indication.
 *
 * In reality, the provider may utilize the system API to monitor the
 * system-wide process creation event, and generate a corresponding
 * CIM_InstCreation indication via the lifecycle context; the same goes
 * for CIM_InstDeletion, CIM_InstModification, CIM_InstRead,
 * CIM_InstMethodCall, etc.
 */
MI_Uint32 MI_CALL TriggerIndication(
    _In_ void* callbackdata)
{
  XYZ_Process_Self* self = (XYZ_Process_Self*)callbackdata;
  MI_LifecycleIndicationContext* context = self-&gt;context;
  MI_Uint32 seqno = self-&gt;seqno++;
  MI_Uint32 index = seqno % PROCESS_COUNT;

  /*
   * When practical, the provider developer needs to get the process
   * creation event, for example by monitoring a system event or 
   * responding to a system API, and then trigger a Cim_InstCreation
   * indication.
   *
   * In order to trigger a CIM_InstCreation indication, the XYZ_Process
   * instance needs to be created first. 
   * After that, call MI_LifecycleIndicationContext_PostCreate function.
   *
   * The following sample code shows how to create a XYZ_Process
   * instance and trigger a CIM_InstCreation indication of XYZ_Process.
   */
  if( self-&gt;types &amp; MI_LIFECYCLE_INDICATION_CREATE )
  {
    XYZ_Process process;
    MI_Result r;
    r = MI_LifecycleIndicationContext_ConstructInstance(
      context, &amp;XYZ_Process_rtti, &amp;process.__instance);
    if (r == MI_RESULT_OK)
    {
      r = _SetPropertyValue(index, &amp;process);
      if ( r == MI_RESULT_OK )
        /* Post CIM_InstCreation indication from background thread */
        MI_LifecycleIndicationContext_PostCreate(context, 
            &amp;process.__instance);

      /* Destroy the instance */
      MI_Instance_Destruct(&amp;process.__instance);
    }
  }
  return 1;
}

/*===================================================================
**
** Thread proc to post the indication periodically
**
**===================================================================*/
MI_Uint32 THREAD_API fireIndication(void* param)
{
  SelfStruct* self = (SelfStruct*)param;
  MI_Uint32 exitvalue = 1;

  if ( !self || !self-&gt;context || !self-&gt;postindication )
  {
    exitvalue = 0;
    goto EXIT;
  }

  /* initialize random seed: */
  SRAND();

  /* produce and post indication */
  while( MI_TRUE != self-&gt;disabling )
  {
    if ( 0 == self-&gt;postindication(self) )
      break;

    /* randomly sleep */
    Sleep_Milliseconds(rand() % 1000 + 500);
  }

EXIT:
  Thread_Exit(exitvalue);
  return exitvalue;
}
</pre></div>

<p>An alternative way to generate a lifecycle indication is to define an indication
class that derives from the lifecycle indication class. For example, consider
the &lsquo;<samp>ABC_Process</samp>&rsquo; class below.  &lsquo;<samp>ABC_ProcessCreation</samp>&rsquo; is defined so 
as to generate a CIM_InstCreation indication for the &lsquo;<samp>ABC_Process</samp>&rsquo; class:
</p>
<div class="example">
<pre class="verbatim">class ABC_Process : CIM_Process
{
  uint32 runningTime;
  
  [static]
  uint32 Create( [in] string imageName, [out] CIM_Process REF process );
};

class ABC_ProcessCreation : CIM_InstCreation
{
};
</pre></div>


<a name="More-sample-code-for-indications-_0028experimental_0029"></a>
<h4 class="subsubsection">8.3.8.3 More sample code for indications (<em>experimental</em>)</h4>

<p>For more detailed examples of indication implementations, please see 
the Indication subdirectory under the samples directory.
</p>

<a name="Building-the-provider"></a>
<h3 class="section">8.4 Building the provider</h3>

<p>To build the provider with the generated <code>GNUmakefile</code> just type
<code>make</code>. This creates a shared library, containing the provider. On Linux,
this file will be named &lsquo;<samp>libxyzconnector.so</samp>&rsquo;.
</p>
<a name="Registering-the-provider-1"></a>
<h3 class="section">8.5 Registering the provider</h3>

<p>To register the provider, use the &lsquo;<samp>omireg</samp>&rsquo; tool, which creates a
registration file (&lsquo;<samp>xyzconnector.reg</samp>&rsquo;) under the registration
directory and copies the provider to the &lsquo;<samp>lib</samp>&rsquo; directory. For example:
</p>
<div class="example">
<pre class="example">$ omireg libxyzconnector.so
Created /opt/omi/lib/libxyzconnector.so
Created /opt/omi/etc/omiregister/root-cimv2/xyzconnector.reg
</pre></div>

<p>By default the provider is hosted in the same process as the server. To host
the provider in a separate process see the &lsquo;<samp>--hosting</samp>&rsquo; option.
</p>
<p>Also by default the provider services the &lsquo;<samp>root/cimv2</samp>&rsquo; namespace. To
change the namespace, see the &lsquo;<samp>--namespace</samp>&rsquo; option.
</p>
<p>For more help with the &lsquo;<samp>omireg</samp>&rsquo; tool, use the &lsquo;<samp>-h</samp>&rsquo; option.
</p>
<p>The contents of the &lsquo;<samp>xyzconnector.reg</samp>&rsquo; file are listed below.
</p>
<div class="example">
<pre class="verbatim"># omireg /home/someuser/connector/libxyzconnector.so
HOSTING=@inproc@
LIBRARY=xyzconnector
CLASS=XYZ_Connector{XYZ_Widget,XYZ_Gadget}
CLASS=XYZ_Gadget
CLASS=XYZ_Widget
</pre></div>

<p>It is better to use <code>omireg</code> to re-generate these files rather than
editing them directly. If you do edit them, you should only need to change
the hosting model. The supported hosting models include:
</p>
<ul>
<li> <strong>@inproc@</strong> &ndash; provider runs in same process as server.
</li><li> <strong>@requestor@</strong> &ndash; provider runs in separate process as the requester&rsquo;s 
user (the client&rsquo;s authenticated user).
</li><li> <strong>USERNAME</strong> &ndash; provider runs as this specified user.
</li></ul>

<a name="Validating-the-provider"></a>
<h3 class="section">8.6 Validating the provider</h3>

<p>To validate the provider, use the &lsquo;<samp>omicli</samp>&rsquo; tool to send requests to the new
providers. The following command enumerates instances of the new &lsquo;<samp>Widget</samp>&rsquo;
provider.
</p>
<div class="example">
<pre class="example"># omicli ei root/cimv2 XYZ_Widget
</pre></div>


<a name="Frog-Provider-Sources"></a>
<h2 class="appendix">Appendix A Frog Provider Sources</h2>

<a name="schema_002emof"></a>
<h3 class="section">A.1 &lsquo;<samp>schema.mof</samp>&rsquo;</h3>

<div class="example">
<pre class="verbatim">class XYZ_Frog
{
    [Key] String Name;
    Uint32 Weight;
    String Color;
};
</pre></div>

<a name="XYZ_005fFrog_002eh"></a>
<h3 class="section">A.2 &lsquo;<samp>XYZ_Frog.h</samp>&rsquo;</h3>

<div class="example">
<pre class="verbatim">/* @migen@ */
/*
**=====================================================================
**
** WARNING: THIS FILE WAS AUTOMATICALLY GENERATED. PLEASE DO NOT EDIT.
**
**=====================================================================
*/
#ifndef _XYZ_Frog_h
#define _XYZ_Frog_h

#include &lt;MI.h&gt;

/*
**=====================================================================
**
** XYZ_Frog [XYZ_Frog]
**
** Keys:
**    Name
**
**=====================================================================
*/

typedef struct _XYZ_Frog
{
    MI_Instance __instance;
    /* XYZ_Frog properties */
    /*KEY*/ MI_ConstStringField Name;
    MI_ConstUint32Field Weight;
    MI_ConstStringField Color;
}
XYZ_Frog;

typedef struct _XYZ_Frog_Ref
{
    XYZ_Frog* value;
    MI_Boolean exists;
    MI_Uint8 flags;
}
XYZ_Frog_Ref;

typedef struct _XYZ_Frog_ConstRef
{
    MI_CONST XYZ_Frog* value;
    MI_Boolean exists;
    MI_Uint8 flags;
}
XYZ_Frog_ConstRef;

typedef struct _XYZ_Frog_Array
{
    struct _XYZ_Frog** data;
    MI_Uint32 size;
}
XYZ_Frog_Array;

typedef struct _XYZ_Frog_ConstArray
{
    struct _XYZ_Frog MI_CONST* MI_CONST* data;
    MI_Uint32 size;
}
XYZ_Frog_ConstArray;

typedef struct _XYZ_Frog_ArrayRef
{
    XYZ_Frog_Array value;
    MI_Boolean exists;
    MI_Uint8 flags;
}
XYZ_Frog_ArrayRef;

typedef struct _XYZ_Frog_ConstArrayRef
{
    XYZ_Frog_ConstArray value;
    MI_Boolean exists;
    MI_Uint8 flags;
}
XYZ_Frog_ConstArrayRef;

MI_EXTERN_C MI_CONST MI_ClassDecl XYZ_Frog_rtti;

MI_INLINE MI_Result MI_CALL XYZ_Frog_Construct(
    XYZ_Frog* self,
    MI_Context* context)
{
    return MI_ConstructInstance(context, &amp;XYZ_Frog_rtti,
        (MI_Instance*)&amp;self-&gt;__instance);
}

MI_INLINE MI_Result MI_CALL XYZ_Frog_Clone(
    const XYZ_Frog* self,
    XYZ_Frog** newInstance)
{
    return MI_Instance_Clone(
        &amp;self-&gt;__instance, (MI_Instance**)newInstance);
}

MI_INLINE MI_Boolean MI_CALL XYZ_Frog_IsA(
    const MI_Instance* self)
{
    MI_Boolean res = MI_FALSE;
    return MI_Instance_IsA( self, &amp;XYZ_Frog_rtti, &amp;res )
             == MI_RESULT_OK &amp;&amp; res;
}

MI_INLINE MI_Result MI_CALL XYZ_Frog_Destruct(XYZ_Frog* self)
{
    return MI_Instance_Destruct(&amp;self-&gt;__instance);
}

MI_INLINE MI_Result MI_CALL XYZ_Frog_Delete(XYZ_Frog* self)
{
    return MI_Instance_Delete(&amp;self-&gt;__instance);
}

MI_INLINE MI_Result MI_CALL XYZ_Frog_Post(
    const XYZ_Frog* self,
    MI_Context* context)
{
    return MI_PostInstance(context, &amp;self-&gt;__instance);
}

MI_INLINE MI_Result MI_CALL XYZ_Frog_Set_Name(
    XYZ_Frog* self,
    const MI_Char* str)
{
    return self-&gt;__instance.ft-&gt;SetElementAt(
        (MI_Instance*)&amp;self-&gt;__instance,
        0,
        (MI_Value*)&amp;str,
        MI_STRING,
        0);
}

MI_INLINE MI_Result MI_CALL XYZ_Frog_SetPtr_Name(
    XYZ_Frog* self,
    const MI_Char* str)
{
    return self-&gt;__instance.ft-&gt;SetElementAt(
        (MI_Instance*)&amp;self-&gt;__instance,
        0,
        (MI_Value*)&amp;str,
        MI_STRING,
        MI_FLAG_BORROW);
}

MI_INLINE MI_Result MI_CALL XYZ_Frog_Clear_Name(
    XYZ_Frog* self)
{
    return self-&gt;__instance.ft-&gt;ClearElementAt(
        (MI_Instance*)&amp;self-&gt;__instance,
        0);
}

MI_INLINE MI_Result MI_CALL XYZ_Frog_Set_Weight(
    XYZ_Frog* self,
    MI_Uint32 x)
{
    ((MI_Uint32Field*)&amp;self-&gt;Weight)-&gt;value = x;
    ((MI_Uint32Field*)&amp;self-&gt;Weight)-&gt;exists = 1;
    return MI_RESULT_OK;
}

MI_INLINE MI_Result MI_CALL XYZ_Frog_Clear_Weight(
    XYZ_Frog* self)
{
    memset((void*)&amp;self-&gt;Weight, 0, sizeof(self-&gt;Weight));
    return MI_RESULT_OK;
}

MI_INLINE MI_Result MI_CALL XYZ_Frog_Set_Color(
    XYZ_Frog* self,
    const MI_Char* str)
{
    return self-&gt;__instance.ft-&gt;SetElementAt(
        (MI_Instance*)&amp;self-&gt;__instance,
        2,
        (MI_Value*)&amp;str,
        MI_STRING,
        0);
}

MI_INLINE MI_Result MI_CALL XYZ_Frog_SetPtr_Color(
    XYZ_Frog* self,
    const MI_Char* str)
{
    return self-&gt;__instance.ft-&gt;SetElementAt(
        (MI_Instance*)&amp;self-&gt;__instance,
        2,
        (MI_Value*)&amp;str,
        MI_STRING,
        MI_FLAG_BORROW);
}

MI_INLINE MI_Result MI_CALL XYZ_Frog_Clear_Color(
    XYZ_Frog* self)
{
    return self-&gt;__instance.ft-&gt;ClearElementAt(
        (MI_Instance*)&amp;self-&gt;__instance,
        2);
}

/*
**=====================================================================
**
** XYZ_Frog provider function prototypes
**
**=====================================================================
*/

/* The developer may optionally define this structure */
typedef struct _XYZ_Frog_Self XYZ_Frog_Self;

MI_EXTERN_C void MI_CALL XYZ_Frog_Load(
    XYZ_Frog_Self** self,
    MI_Module_Self* selfModule,
    MI_Context* context);

MI_EXTERN_C void MI_CALL XYZ_Frog_Unload(
    XYZ_Frog_Self* self,
    MI_Context* context);

MI_EXTERN_C void MI_CALL XYZ_Frog_EnumerateInstances(
    XYZ_Frog_Self* self,
    MI_Context* context,
    const MI_Char* nameSpace,
    const MI_Char* className,
    const MI_PropertySet* propertySet,
    MI_Boolean keysOnly,
    const MI_Filter* filter);

MI_EXTERN_C void MI_CALL XYZ_Frog_GetInstance(
    XYZ_Frog_Self* self,
    MI_Context* context,
    const MI_Char* nameSpace,
    const MI_Char* className,
    const XYZ_Frog* instanceName,
    const MI_PropertySet* propertySet);

MI_EXTERN_C void MI_CALL XYZ_Frog_CreateInstance(
    XYZ_Frog_Self* self,
    MI_Context* context,
    const MI_Char* nameSpace,
    const MI_Char* className,
    const XYZ_Frog* newInstance);

MI_EXTERN_C void MI_CALL XYZ_Frog_ModifyInstance(
    XYZ_Frog_Self* self,
    MI_Context* context,
    const MI_Char* nameSpace,
    const MI_Char* className,
    const XYZ_Frog* modifiedInstance,
    const MI_PropertySet* propertySet);

MI_EXTERN_C void MI_CALL XYZ_Frog_DeleteInstance(
    XYZ_Frog_Self* self,
    MI_Context* context,
    const MI_Char* nameSpace,
    const MI_Char* className,
    const XYZ_Frog* instanceName);


/*
**=====================================================================
**
** XYZ_Frog_Class
**
**=====================================================================
*/

#ifdef __cplusplus
# include &lt;micxx/micxx.h&gt;

MI_BEGIN_NAMESPACE

class XYZ_Frog_Class : public Instance
{
public:

    typedef XYZ_Frog Self;

    XYZ_Frog_Class() :
        Instance(&amp;XYZ_Frog_rtti)
    {
    }

    XYZ_Frog_Class(
        const XYZ_Frog* instanceName,
        bool keysOnly) :
        Instance(
            &amp;XYZ_Frog_rtti,
            &amp;instanceName-&gt;__instance,
            keysOnly)
    {
    }

    XYZ_Frog_Class(
        const MI_ClassDecl* clDecl,
        const MI_Instance* instance,
        bool keysOnly) :
        Instance(clDecl, instance, keysOnly)
    {
    }

    XYZ_Frog_Class(
        const MI_ClassDecl* clDecl) :
        Instance(clDecl)
    {
    }

    XYZ_Frog_Class&amp; operator=(
        const XYZ_Frog_Class&amp; x)
    {
        CopyRef(x);
        return *this;
    }

    XYZ_Frog_Class(
        const XYZ_Frog_Class&amp; x) :
        Instance(x)
    {
    }

    static const MI_ClassDecl* GetClassDecl()
    {
        return &amp;XYZ_Frog_rtti;
    }

    //
    // XYZ_Frog_Class.Name
    //

    const Field&lt;String&gt;&amp; Name() const
    {
        const size_t n = offsetof(Self, Name);
        return GetField&lt;String&gt;(n);
    }

    void Name(const Field&lt;String&gt;&amp; x)
    {
        const size_t n = offsetof(Self, Name);
        GetField&lt;String&gt;(n) = x;
    }

    const String&amp; Name_value() const
    {
        const size_t n = offsetof(Self, Name);
        return GetField&lt;String&gt;(n).value;
    }

    void Name_value(const String&amp; x)
    {
        const size_t n = offsetof(Self, Name);
        return GetField&lt;String&gt;(n).Set(x);
    }

    bool Name_exists() const
    {
        const size_t n = offsetof(Self, Name);
        return GetField&lt;String&gt;(n).exists ? true : false;
    }

    void Name_clear()
    {
        const size_t n = offsetof(Self, Name);
        GetField&lt;String&gt;(n).Clear();
    }

    //
    // XYZ_Frog_Class.Weight
    //

    const Field&lt;Uint32&gt;&amp; Weight() const
    {
        const size_t n = offsetof(Self, Weight);
        return GetField&lt;Uint32&gt;(n);
    }

    void Weight(const Field&lt;Uint32&gt;&amp; x)
    {
        const size_t n = offsetof(Self, Weight);
        GetField&lt;Uint32&gt;(n) = x;
    }

    const Uint32&amp; Weight_value() const
    {
        const size_t n = offsetof(Self, Weight);
        return GetField&lt;Uint32&gt;(n).value;
    }

    void Weight_value(const Uint32&amp; x)
    {
        const size_t n = offsetof(Self, Weight);
        return GetField&lt;Uint32&gt;(n).Set(x);
    }

    bool Weight_exists() const
    {
        const size_t n = offsetof(Self, Weight);
        return GetField&lt;Uint32&gt;(n).exists ? true : false;
    }

    void Weight_clear()
    {
        const size_t n = offsetof(Self, Weight);
        GetField&lt;Uint32&gt;(n).Clear();
    }

    //
    // XYZ_Frog_Class.Color
    //

    const Field&lt;String&gt;&amp; Color() const
    {
        const size_t n = offsetof(Self, Color);
        return GetField&lt;String&gt;(n);
    }

    void Color(const Field&lt;String&gt;&amp; x)
    {
        const size_t n = offsetof(Self, Color);
        GetField&lt;String&gt;(n) = x;
    }

    const String&amp; Color_value() const
    {
        const size_t n = offsetof(Self, Color);
        return GetField&lt;String&gt;(n).value;
    }

    void Color_value(const String&amp; x)
    {
        const size_t n = offsetof(Self, Color);
        return GetField&lt;String&gt;(n).Set(x);
    }

    bool Color_exists() const
    {
        const size_t n = offsetof(Self, Color);
        return GetField&lt;String&gt;(n).exists ? true : false;
    }

    void Color_clear()
    {
        const size_t n = offsetof(Self, Color);
        GetField&lt;String&gt;(n).Clear();
    }
};

typedef Array&lt;XYZ_Frog_Class&gt; XYZ_Frog_ClassA;

MI_END_NAMESPACE

#endif /* __cplusplus */

#endif /* _XYZ_Frog_h */
</pre></div>

<a name="XYZ_005fFrog_005fClass_005fProvider_002eh"></a>
<h3 class="section">A.3 &lsquo;<samp>XYZ_Frog_Class_Provider.h</samp>&rsquo;</h3>

<div class="example">
<pre class="verbatim">/* @migen@ */
#ifndef _XYZ_Frog_Class_Provider_h
#define _XYZ_Frog_Class_Provider_h

#include &quot;XYZ_Frog.h&quot;
#ifdef __cplusplus
# include &lt;micxx/micxx.h&gt;
# include &quot;module.h&quot;

MI_BEGIN_NAMESPACE

/*
**=====================================================================
**
** XYZ_Frog provider class declaration
**
**=====================================================================
*/

class XYZ_Frog_Class_Provider
{
/* @MIGEN.BEGIN@ CAUTION: PLEASE DO NOT EDIT OR DELETE THIS LINE. */
private:
    Module* m_Module;

public:
    XYZ_Frog_Class_Provider(
        Module* module);

    ~XYZ_Frog_Class_Provider();

    void Load(
        Context&amp; context);

    void Unload(
        Context&amp; context);

    void EnumerateInstances(
        Context&amp; context,
        const String&amp; nameSpace,
        const PropertySet&amp; propertySet,
        bool keysOnly,
        const MI_Filter* filter);

    void GetInstance(
        Context&amp; context,
        const String&amp; nameSpace,
        const XYZ_Frog_Class&amp; instance,
        const PropertySet&amp; propertySet);

    void CreateInstance(
        Context&amp; context,
        const String&amp; nameSpace,
        const XYZ_Frog_Class&amp; newInstance);

    void ModifyInstance(
        Context&amp; context,
        const String&amp; nameSpace,
        const XYZ_Frog_Class&amp; modifiedInstance,
        const PropertySet&amp; propertySet);

    void DeleteInstance(
        Context&amp; context,
        const String&amp; nameSpace,
        const XYZ_Frog_Class&amp; instance);

/* @MIGEN.END@ CAUTION: PLEASE DO NOT EDIT OR DELETE THIS LINE. */
};

MI_END_NAMESPACE

#endif /* __cplusplus */

#endif /* _XYZ_Frog_Class_Provider_h */

</pre></div>

<a name="XYZ_005fFrog_005fClass_005fProvider_002ecpp"></a>
<h3 class="section">A.4 &lsquo;<samp>XYZ_Frog_Class_Provider.cpp</samp>&rsquo;</h3>

<div class="example">
<pre class="verbatim">/* @migen@ */
#include &lt;MI.h&gt;
#include &quot;XYZ_Frog_Class_Provider.h&quot;

MI_BEGIN_NAMESPACE

XYZ_Frog_Class_Provider::XYZ_Frog_Class_Provider(
    Module* module) :
    m_Module(module)
{
}

XYZ_Frog_Class_Provider::~XYZ_Frog_Class_Provider()
{
}

void XYZ_Frog_Class_Provider::Load(
        Context&amp; context)
{
    context.Post(MI_RESULT_OK);
}

void XYZ_Frog_Class_Provider::Unload(
        Context&amp; context)
{
    context.Post(MI_RESULT_OK);
}

void XYZ_Frog_Class_Provider::EnumerateInstances(
    Context&amp; context,
    const String&amp; nameSpace,
    const PropertySet&amp; propertySet,
    bool keysOnly,
    const MI_Filter* filter)
{
    XYZ_Frog_Class frog1;
    frog1.Name_value(&quot;Fred&quot;);
    frog1.Weight_value(55);
    frog1.Color_value(&quot;Green&quot;);
    context.Post(frog1);

    XYZ_Frog_Class frog2;
    frog2.Name_value(&quot;Sam&quot;);
    frog2.Weight_value(65);
    frog2.Color_value(&quot;Blue&quot;);
    context.Post(frog2);

    context.Post(MI_RESULT_OK);
}

void XYZ_Frog_Class_Provider::GetInstance(
    Context&amp; context,
    const String&amp; nameSpace,
    const XYZ_Frog_Class&amp; instanceName,
    const PropertySet&amp; propertySet)
{
    context.Post(MI_RESULT_NOT_SUPPORTED);
}

void XYZ_Frog_Class_Provider::CreateInstance(
    Context&amp; context,
    const String&amp; nameSpace,
    const XYZ_Frog_Class&amp; newInstance)
{
    context.Post(MI_RESULT_NOT_SUPPORTED);
}

void XYZ_Frog_Class_Provider::ModifyInstance(
    Context&amp; context,
    const String&amp; nameSpace,
    const XYZ_Frog_Class&amp; modifiedInstance,
    const PropertySet&amp; propertySet)
{
    context.Post(MI_RESULT_NOT_SUPPORTED);
}

void XYZ_Frog_Class_Provider::DeleteInstance(
    Context&amp; context,
    const String&amp; nameSpace,
    const XYZ_Frog_Class&amp; instanceName)
{
    context.Post(MI_RESULT_NOT_SUPPORTED);
}


MI_END_NAMESPACE
</pre></div>

<a name="module_002eh"></a>
<h3 class="section">A.5 &lsquo;<samp>module.h</samp>&rsquo;</h3>

<div class="example">
<pre class="verbatim">#ifndef _Module_t_h
#define _Module_t_h

#include &lt;MI.h&gt;
#include &lt;micxx/micxx.h&gt;

MI_BEGIN_NAMESPACE

/*  An instance of this class is automatically created when
    the library is loaded, so it's a convenient place to store 
    global data associated with the module */
class Module
{
public:
    Module();
    ~Module();

};

MI_END_NAMESPACE
#endif /* _Module_t_h */

</pre></div>

<a name="module_002ecpp"></a>
<h3 class="section">A.6 &lsquo;<samp>module.cpp</samp>&rsquo;</h3>

<div class="example">
<pre class="verbatim">#include &lt;MI.h&gt;
#include &quot;module.h&quot;

MI_BEGIN_NAMESPACE

Module::Module()
{
}

Module::~Module()
{
}

MI_END_NAMESPACE

</pre></div>

<a name="schema_002ec"></a>
<h3 class="section">A.7 &lsquo;<samp>schema.c</samp>&rsquo;</h3>

<div class="example">
<pre class="verbatim">/* @migen@ */
/*
**=====================================================================
**
** WARNING: THIS FILE WAS AUTOMATICALLY GENERATED. PLEASE DO NOT EDIT.
**
**=====================================================================
*/
#include &lt;ctype.h&gt;
#include &lt;MI.h&gt;
#include &quot;XYZ_Frog.h&quot;

/*
**=====================================================================
**
** Schema Declaration
**
**=====================================================================
*/

extern MI_SchemaDecl schemaDecl;

/*
**=====================================================================
**
** Qualifier declarations
**
**=====================================================================
*/

/*
**=====================================================================
**
** XYZ_Frog
**
**=====================================================================
*/

/* property XYZ_Frog.Name */
static MI_CONST MI_PropertyDecl XYZ_Frog_Name_prop =
{
    MI_FLAG_PROPERTY|MI_FLAG_KEY, /* flags */
    0x006E6504, /* code */
    MI_T(&quot;Name&quot;), /* name */
    NULL, /* qualifiers */
    0, /* numQualifiers */
    MI_STRING, /* type */
    NULL, /* className */
    0, /* subscript */
    offsetof(XYZ_Frog, Name), /* offset */
    MI_T(&quot;XYZ_Frog&quot;), /* origin */
    MI_T(&quot;XYZ_Frog&quot;), /* propagator */
    NULL,
};

/* property XYZ_Frog.Weight */
static MI_CONST MI_PropertyDecl XYZ_Frog_Weight_prop =
{
    MI_FLAG_PROPERTY, /* flags */
    0x00777406, /* code */
    MI_T(&quot;Weight&quot;), /* name */
    NULL, /* qualifiers */
    0, /* numQualifiers */
    MI_UINT32, /* type */
    NULL, /* className */
    0, /* subscript */
    offsetof(XYZ_Frog, Weight), /* offset */
    MI_T(&quot;XYZ_Frog&quot;), /* origin */
    MI_T(&quot;XYZ_Frog&quot;), /* propagator */
    NULL,
};

/* property XYZ_Frog.Color */
static MI_CONST MI_PropertyDecl XYZ_Frog_Color_prop =
{
    MI_FLAG_PROPERTY, /* flags */
    0x00637205, /* code */
    MI_T(&quot;Color&quot;), /* name */
    NULL, /* qualifiers */
    0, /* numQualifiers */
    MI_STRING, /* type */
    NULL, /* className */
    0, /* subscript */
    offsetof(XYZ_Frog, Color), /* offset */
    MI_T(&quot;XYZ_Frog&quot;), /* origin */
    MI_T(&quot;XYZ_Frog&quot;), /* propagator */
    NULL,
};

static MI_PropertyDecl MI_CONST* MI_CONST XYZ_Frog_props[] =
{
    &amp;XYZ_Frog_Name_prop,
    &amp;XYZ_Frog_Weight_prop,
    &amp;XYZ_Frog_Color_prop,
};

static MI_CONST MI_ProviderFT XYZ_Frog_funcs =
{
  (MI_ProviderFT_Load)XYZ_Frog_Load,
  (MI_ProviderFT_Unload)XYZ_Frog_Unload,
  (MI_ProviderFT_GetInstance)XYZ_Frog_GetInstance,
  (MI_ProviderFT_EnumerateInstances)XYZ_Frog_EnumerateInstances,
  (MI_ProviderFT_CreateInstance)XYZ_Frog_CreateInstance,
  (MI_ProviderFT_ModifyInstance)XYZ_Frog_ModifyInstance,
  (MI_ProviderFT_DeleteInstance)XYZ_Frog_DeleteInstance,
  (MI_ProviderFT_AssociatorInstances)NULL,
  (MI_ProviderFT_ReferenceInstances)NULL,
  (MI_ProviderFT_EnableIndications)NULL,
  (MI_ProviderFT_DisableIndications)NULL,
  (MI_ProviderFT_Subscribe)NULL,
  (MI_ProviderFT_Unsubscribe)NULL,
  (MI_ProviderFT_Invoke)NULL,
};

/* class XYZ_Frog */
MI_CONST MI_ClassDecl XYZ_Frog_rtti =
{
    MI_FLAG_CLASS, /* flags */
    0x00786708, /* code */
    MI_T(&quot;XYZ_Frog&quot;), /* name */
    NULL, /* qualifiers */
    0, /* numQualifiers */
    XYZ_Frog_props, /* properties */
    MI_COUNT(XYZ_Frog_props), /* numProperties */
    sizeof(XYZ_Frog), /* size */
    NULL, /* superClass */
    NULL, /* superClassDecl */
    NULL, /* methods */
    0, /* numMethods */
    &amp;schemaDecl, /* schema */
    &amp;XYZ_Frog_funcs, /* functions */
};

/*
**=====================================================================
**
** __mi_server
**
**=====================================================================
*/

MI_Server* __mi_server;
/*
**=====================================================================
**
** Schema
**
**=====================================================================
*/

static MI_ClassDecl MI_CONST* MI_CONST classes[] =
{
    &amp;XYZ_Frog_rtti,
};

MI_SchemaDecl schemaDecl =
{
    NULL, /* qualifierDecls */
    0, /* numQualifierDecls */
    classes, /* classDecls */
    MI_COUNT(classes), /* classDecls */
};

/*
**=====================================================================
**
** MI_Server Methods
**
**=====================================================================
*/

MI_Result MI_CALL MI_Server_GetVersion(
    MI_Uint32* version){
    return __mi_server-&gt;serverFT-&gt;GetVersion(version);
}

MI_Result MI_CALL MI_Server_GetSystemName(
    const MI_Char** systemName)
{
    return __mi_server-&gt;serverFT-&gt;GetSystemName(systemName);
}

</pre></div>

<a name="stubs_002ecpp"></a>
<h3 class="section">A.8 &lsquo;<samp>stubs.cpp</samp>&rsquo;</h3>

<div class="example">
<pre class="verbatim">/* @migen@ */
/*
**=====================================================================
**
** WARNING: THIS FILE WAS AUTOMATICALLY GENERATED. PLEASE DO NOT EDIT.
**
**=====================================================================
*/
#include &lt;MI.h&gt;
#include &quot;module.h&quot;
#include &quot;XYZ_Frog_Class_Provider.h&quot;

using namespace mi;

MI_EXTERN_C void MI_CALL XYZ_Frog_Load(
    XYZ_Frog_Self** self,
    MI_Module_Self* selfModule,
    MI_Context* context)
{
    MI_Result r = MI_RESULT_OK;
    Context ctx(context, &amp;r);
    XYZ_Frog_Class_Provider* prov = 
        new XYZ_Frog_Class_Provider((Module*)selfModule);

    prov-&gt;Load(ctx);
    if (MI_RESULT_OK != r)
    {
        delete prov;
        MI_PostResult(context, r);
        return;
    }
    *self = (XYZ_Frog_Self*)prov;
    MI_PostResult(context, MI_RESULT_OK);
}

MI_EXTERN_C void MI_CALL XYZ_Frog_Unload(
    XYZ_Frog_Self* self,
    MI_Context* context)
{
    MI_Result r = MI_RESULT_OK;
    Context ctx(context, &amp;r);
    XYZ_Frog_Class_Provider* prov = (XYZ_Frog_Class_Provider*)self;

    prov-&gt;Unload(ctx);
    delete ((XYZ_Frog_Class_Provider*)self);
    MI_PostResult(context, r);
}

MI_EXTERN_C void MI_CALL XYZ_Frog_EnumerateInstances(
    XYZ_Frog_Self* self,
    MI_Context* context,
    const MI_Char* nameSpace,
    const MI_Char* className,
    const MI_PropertySet* propertySet,
    MI_Boolean keysOnly,
    const MI_Filter* filter)
{
    XYZ_Frog_Class_Provider* cxxSelf =((XYZ_Frog_Class_Provider*)self);
    Context  cxxContext(context);

    cxxSelf-&gt;EnumerateInstances(
        cxxContext,
        nameSpace,
        __PropertySet(propertySet),
        __bool(keysOnly),
        filter);
}

MI_EXTERN_C void MI_CALL XYZ_Frog_GetInstance(
    XYZ_Frog_Self* self,
    MI_Context* context,
    const MI_Char* nameSpace,
    const MI_Char* className,
    const XYZ_Frog* instanceName,
    const MI_PropertySet* propertySet)
{
    XYZ_Frog_Class_Provider* cxxSelf =((XYZ_Frog_Class_Provider*)self);
    Context  cxxContext(context);
    XYZ_Frog_Class cxxInstanceName(instanceName, true);

    cxxSelf-&gt;GetInstance(
        cxxContext,
        nameSpace,
        cxxInstanceName,
        __PropertySet(propertySet));
}

MI_EXTERN_C void MI_CALL XYZ_Frog_CreateInstance(
    XYZ_Frog_Self* self,
    MI_Context* context,
    const MI_Char* nameSpace,
    const MI_Char* className,
    const XYZ_Frog* newInstance)
{
    XYZ_Frog_Class_Provider* cxxSelf =((XYZ_Frog_Class_Provider*)self);
    Context  cxxContext(context);
    XYZ_Frog_Class cxxNewInstance(newInstance, false);

    cxxSelf-&gt;CreateInstance(cxxContext, nameSpace, cxxNewInstance);
}

MI_EXTERN_C void MI_CALL XYZ_Frog_ModifyInstance(
    XYZ_Frog_Self* self,
    MI_Context* context,
    const MI_Char* nameSpace,
    const MI_Char* className,
    const XYZ_Frog* modifiedInstance,
    const MI_PropertySet* propertySet)
{
    XYZ_Frog_Class_Provider* cxxSelf =((XYZ_Frog_Class_Provider*)self);
    Context  cxxContext(context);
    XYZ_Frog_Class cxxModifiedInstance(modifiedInstance, false);

    cxxSelf-&gt;ModifyInstance(
        cxxContext,
        nameSpace,
        cxxModifiedInstance,
        __PropertySet(propertySet));
}

MI_EXTERN_C void MI_CALL XYZ_Frog_DeleteInstance(
    XYZ_Frog_Self* self,
    MI_Context* context,
    const MI_Char* nameSpace,
    const MI_Char* className,
    const XYZ_Frog* instanceName)
{
    XYZ_Frog_Class_Provider* cxxSelf =((XYZ_Frog_Class_Provider*)self);
    Context  cxxContext(context);
    XYZ_Frog_Class cxxInstanceName(instanceName, true);

    cxxSelf-&gt;DeleteInstance(cxxContext, nameSpace, cxxInstanceName);
}


MI_EXTERN_C MI_SchemaDecl schemaDecl;

void MI_CALL Load(MI_Module_Self** self, struct _MI_Context* context)
{
    *self = (MI_Module_Self*)new Module;
}

void MI_CALL Unload(MI_Module_Self* self, struct _MI_Context* context)
{
    Module* module = (Module*)self;
    delete module;
}

MI_EXTERN_C MI_EXPORT MI_Module* MI_MAIN_CALL MI_Main(MI_Server* server)
{
/* WARNING: THIS FUNCTION AUTOMATICALLY GENERATED. PLEASE DO NOT EDIT. */
    extern MI_Server* __mi_server;
    static MI_Module module;
    __mi_server = server;
    module.flags |= MI_MODULE_FLAG_STANDARD_QUALIFIERS;
    module.flags |= MI_MODULE_FLAG_CPLUSPLUS;
    module.charSize = sizeof(MI_Char);
    module.version = MI_VERSION;
    module.generatorVersion = MI_MAKE_VERSION(1,0,0);
    module.schemaDecl = &amp;schemaDecl;
    module.Load = Load;
    module.Unload = Unload;
    return &amp;module;
}

</pre></div>

<a name="GNUmakefile"></a>
<h3 class="section">A.9 &lsquo;<samp>GNUmakefile</samp>&rsquo;</h3>

<div class="example">
<pre class="verbatim">HOST=$(shell hostname)
include ../../../../output/$(shell hostname)/omi.mak

PROVIDER = frog
SOURCES = $(wildcard *.c *.cpp)
CLASSES = XYZ_Frog

$(LIBRARY): $(OBJECTS)
	$(CXX) $(CXXSHLIBFLAGS) $(OBJECTS) -o $(LIBRARY) $(CXXLIBS)

%.o: %.c
	$(CC) -c $(CFLAGS) $(INCLUDES) $&lt; $(CLIBS) -o $@

%.o: %.cpp
	$(CXX) -c $(CXXFLAGS) $(INCLUDES) $&lt; -o $@

reg:
	$(BINDIR)/omireg $(CURDIR)/$(LIBRARY)

gen:
	$(BINDIR)/omigen --cpp -m frog schema.mof XYZ_Frog

clean:
	rm -f $(LIBRARY) $(OBJECTS) $(PROVIDER).reg


</pre></div>

<a name="Asynchronous-Enumerate-Instances-Client-Example"></a>
<h2 class="appendix">Appendix B Asynchronous Enumerate Instances Client Example</h2>

<a name="AsyncEnum_002ecpp"></a>
<h3 class="section">B.1 &lsquo;<samp>AsyncEnum.cpp</samp>&rsquo;</h3>

<div class="example">
<pre class="verbatim">#include &lt;cstdio&gt;
#include &lt;omiclient/client.h&gt;

#define T MI_T

using namespace mi;

class MyHandler : public Handler
{
public:

    MyHandler() : done(false)
    {
    }

    virtual void HandleConnect()
    {
        printf(&quot;==== MyHandler::HandleConnect()\n&quot;);
    }

    virtual void HandleNoOp(Uint64 msgID)
    {
        printf(&quot;==== MyHandler::HandleNoOp()\n&quot;);
    }

    virtual void HandleConnectFailed()
    {
        printf(&quot;==== MyHandler::HandleConnectFailed()\n&quot;);

        // Handler error!
        done = true;
    }

    virtual void HandleDisconnect()
    {
        printf(&quot;==== MyHandler::HandleDisconnect()\n&quot;);
        done = true;
    }

    virtual void HandleInstance(Uint64 msgID, const DInstance&amp; instance)
    {
        printf(&quot;==== MyHandler::HandleInstance()\n&quot;);

        instance.Print();
    }

    virtual void HandleResult(Uint64 msgID, MI_Result result)
    {
        printf(&quot;==== MyHandler::HandleResult()\n&quot;);
        done = true;
    }

    bool done;
};

int main(int argc, const char* argv[])
{
  int r = 0;
  
  // Create handler:
  MyHandler* handler = new MyHandler;
  
  // Construct client:
  Client client(handler);
  
  String locator;
  String username;
  String password;
  
  if (!client.ConnectAsync(locator, username, password))
  {
    // Handle error!
  }
  
  const String nameSpace = &quot;root/omi&quot;;
  const String className = &quot;OMI_Identify&quot;;
  const bool deep = true;
  Uint64 msgID;
  
  if (!client.EnumerateInstancesAsync( nameSpace, className, deep, msgID))
  {
    // Handle error!
  }
  
  // Wait here for 5 seconds for operation to finish.
  while (!handler-&gt;done)
  {
    client.Run(1000);
  }
  
  return r;
}
</pre></div>

<a name="Cross-compiling-OMI"></a>
<h2 class="appendix">Appendix C Cross compiling OMI</h2>

<a name="Synopsis"></a>
<h3 class="section">C.1 Synopsis</h3>

<p>This appendix explains how to build OMI with a cross compiler. Two such
targets are supported today:
</p>
<div class="example">
<pre class="example">MONTAVISTA_IX86_GNU
NETBSD_IX86_GNU
</pre></div>

<p>Additional platforms can be supported by extending the &lsquo;<samp>buildtool</samp>&rsquo; script
(following MONTAVISTA_IX86_GNU target as an example).
</p>
<a name="Terminology"></a>
<h3 class="section">C.2 Terminology</h3>

<p>The &quot;host&quot; platform is where the compiler is run to build OMI. The &quot;target&quot;
platform is where the output binaries files will run. These can be the same,
but in the case of cross-compiling they are different. This appendix uses the
term &quot;target&quot; to refer to the platform where the binaries will be run.
</p>
<a name="Configuring"></a>
<h3 class="section">C.3 Configuring</h3>

<p>By default, the &lsquo;<samp>configure</samp>&rsquo; script guesses the platform based on the host
environment. But with cross-compiling, the platform is given by the &ndash;target
option as shown below:
</p>
<div class="example">
<pre class="example">./configure --target=MONTAVISTA_IX86_GNU
</pre></div>

<p>Additional options are required to specify to location of the cross-compiler
components. These include:
</p>
<div class="example">
<pre class="example">--with-cc=PATH          Use C compiler given by PATH.
--with-cxx=PATH         Use C++ compiler given by PATH.
--with-ar=PATH          Use archive command (ar) given by PATH.
--openssl=PATH          Full path to the &quot;openssl&quot; command.
--opensslcflags=FLAGS   Extra C flags needed for OpenSSL.
                        (<em>e.g.</em> &quot;-I/usr/local/include&quot;).
--openssllibs=FLAGS     Extra library options needed for OpenSSL.
                        (<em>e.g.</em> &quot;-L/usr/local/lib -lssl -lcrypto&quot;).
--openssllibdir=PATH    The path of the directory containing the desired
                        OpenSSL libraries (ssl and crypto).
</pre></div>

<p>So to run configure, one might have something like this:
</p>
<div class="example">
<pre class="example">./configure
    --target=NETBSD_IX86_GNU
    --with-cc=/opt/toolchain/bin/586-gcc
    --with-cxx=/opt/toolchain/bin/586-g++
    --with-ar=/opt/toolchain/bin/586-ar
    --opensslcflags=&quot;-I /opt/toolchain/include&quot;
    --openssllibdir=/opt/toolchain/lib64
    --openssllibs=&quot;-L/opt/toolchain/lib64 -lssl -lcrypto&quot;
</pre></div>

<p>Of course this is only an example. The exact location of these components will
vary.
</p>
<a name="Installing"></a>
<h3 class="section">C.4 Installing</h3>

<p>When cross-compiling, it is obviously no longer possible to simply type
&quot;make install&quot; to install the components (since the components must be copied
to another platform). Instead, components may be installed into an interim
directory and then copied from there onto the target platform. The DESTDIR
variable can be used for this purpose. For example, suppose that we configured
like this:
</p>
<div class="example">
<pre class="example">./configure
    --target=NETBSD_IX86_GNU
    --prefix=/opt/omi
    --with-cc=/opt/toolchain/bin/586-gcc
    --with-cxx=/opt/toolchain/bin/586-g++
    --with-ar=/opt/toolchain/bin/586-ar
    --opensslcflags=&quot;-I /opt/toolchain/include&quot;
    --openssllibdir=/opt/toolchain/lib64
    --openssllibs=&quot;-L/opt/toolchain/lib64 -lssl -lcrypto&quot;
</pre></div>

<p>Next, the installable components can all be copied to an interim directory
called &quot;/tmp/install&quot; like this:
</p>
<div class="example">
<pre class="example">make DESTDIR=/tmp/install install
</pre></div>

<p>Finally, the components can be copied from the /tmp/install directory to
the target machine.
</p>
<a name="NITS-Integrated-Test-System"></a>
<h2 class="appendix">Appendix D NITS Integrated Test System</h2>

<a name="Introduction-1"></a>
<h3 class="section">D.1 Introduction</h3>

<p>This document defines a C unit test framework and instructions for its use. This 
framework is a replacement for existing unit test infrastructure that makes  
debugging, maintenance, and code coverage significantly easier. The unit test 
framework encompasses several related components:
</p>
<ul>
<li> <b>libnits.so</b>: Contains the framework implementation. This binary contains shared 
memory spaces appropriate for test builds only. Product binaries must not link 
to &lsquo;<samp>libnits.so</samp>&rsquo; on official builds.
</li><li> <b>libnitsinj.so</b>: Injects the test framework and any other mocked function tables into 
relevant processes during unit test runs. No one links to this binary directly.
</li><li> <b>libnitsstub.a</b>: Contains no-op implementations of the NITS API for product 
binaries using HOOK_BUILD or DEBUG_BUILD linkage.
</li><li> <b>nits</b>: Contains a command-line interface for running the framework on a set 
of tests. Spawns child processes if necessary, runs test cases, and reports 
results.
</li><li> <b>Unit test shared libraries</b>: Contains product unit test suites. All test cases are declared 
within the .cpp files of these binaries. Links to libnits.so using TEST_BUILD 
linkage.
</li><li> <b>Product shared libraries and executables</b>: Uses macros and either runtime instrumentation or conditional 
blocks of code to run under unit test passes. Should use HOOK_BUILD or 
DEBUG_BUILD linkage.
</li></ul>

<a name="Linkage"></a>
<h3 class="section">D.2 Linkage</h3>

<p>There are five different possible ways to link to the NITS package, each with its own 
consequences:
</p>
<ul>
<li> <b>&lt;default&gt;</b>: All test macros are no-ops and NitsCallSite is minimized. It is not 
possible to hook anything at runtime. This option is used in projects/binaries 
that do not understand NITS.
</li><li> <b>HOOK_BUILD</b>: Test macros call NitsFT stubs in libnitsstub.a. NitsCallSite is 
functional but does not show file/line information. Use the -target option to 
hook selected binaries at runtime. This option is for production shared libraries 
and executables.
</li><li> <b>DEBUG_BUILD</b>: Same as HOOK_BUILD, but includes 
&lsquo;<samp>__FILE__</samp>&rsquo;, &lsquo;<samp>__LINE__</samp>&rsquo;, and &lsquo;<samp>__FUNCTION__</samp>&rsquo; information. This 
option is intended for production shared libraries and executables running 
under a debug/checked build.
</li><li> <b>TEST_BUILD</b>: Test macros call the NITS implementation by linking with 
&lsquo;<samp>libnits.so</samp>&rsquo;. This is for test shared libraries.
</li></ul>

<a name="Project-Setup"></a>
<h3 class="section">D.3 Project Setup</h3>

<p>This section describes the basic source tree configuration steps required to 
access the NITS API. Once these steps are complete, product and test binaries 
are ready to start using the framework. The project will need access to the 
following files from the framework: &lsquo;<samp>nits.h</samp>&rsquo;, &lsquo;<samp>libnits.so</samp>&rsquo;, 
&lsquo;<samp>libpal.a</samp>&rsquo;, &lsquo;<samp>libnitsstub.a</samp>&rsquo;, &lsquo;<samp>nitsstub.obj</samp>&rsquo; and &lsquo;<samp>nits</samp>&rsquo;. 
</p>
<p>The recommended, supported project configuration is as follows:
</p>
<a name="Product-Binaries"></a>
<h4 class="subsection">D.3.1 Product Binaries</h4>

<ul>
<li> Ideally the product code should take the form of a shared library, and executable 
modules should only be thin wrappers over the shared library.
</li><li> Define HOOK_BUILD in product binaries as part of the sources files (for 
checked builds, DEBUG_BUILD provides more file/line information, but it also 
bloats the binary).
</li><li> Include &lsquo;<samp>&lt;nits/base/nits.h&gt;</samp>&rsquo; in product and test source files.
</li><li> Link to &lsquo;<samp>libnitsstub.a</samp>&rsquo; and &lsquo;<samp>libpal.a</samp>&rsquo; from product binaries 
(&lsquo;<samp>$(PALLIBS)</samp>&rsquo; expands to these two libraries).
</li></ul>

<a name="Unit-Test-Binaries"></a>
<h4 class="subsection">D.3.2 Unit Test Binaries</h4>

<ul>
<li> Define TEST_BUILD in unit test binaries as part of the GNUmakefile.
</li><li> Link to &lsquo;<samp>$(UNITTESTLIBS)</samp>&rsquo; from unit test binaries. &lsquo;<samp>$(UNITTESTLIBS)</samp>&rsquo;
expands to everything needed to build the test library.
</li><li> Include &lsquo;<samp>libnits.so</samp>&rsquo;, &lsquo;<samp>libnitsinj.so</samp>&rsquo;, and &lsquo;<samp>nits</samp>&rsquo; 
when distributing unit test binaries to test environments.
</li></ul>


<a name="Pitfalls_002fNotes"></a>
<h4 class="subsection">D.3.3 Pitfalls/Notes</h4>

<ul>
<li> There are drawbacks to using &lsquo;<samp>HOOK_BUILD</samp>&rsquo; 
against executable modules (<em>i.e</em>. the trap table technique for 
calling internal product APIs does not work).
</li></ul>

<a name="Sample-Project"></a>
<h4 class="subsection">D.3.4 Sample Project</h4>

<p>For canonical up-to-date working examples, see the sample product and test
code in the following directories: 
</p>
<ul>
<li> There are examples of various linkage types under: &lsquo;<samp>nits/linkageSample</samp>&rsquo;.
</li><li> There are many test examples under &lsquo;<samp>nits/sample</samp>&rsquo;.
</li><li> There is product code under &lsquo;<samp>nits/sampleproduct</samp>&rsquo;.
</li></ul>

<a name="Deployment"></a>
<h3 class="section">D.4 Deployment</h3>

<p>The nits binaries are built only in the &lsquo;<samp>unittest</samp>&rsquo; environment, <em>i.e.</em> 
when the &lsquo;<samp>--dev</samp>&rsquo; option is passed to the &lsquo;<samp>./configure</samp>&rsquo; script during 
configuration and build. the &lsquo;<samp>nits</samp>&rsquo; executable is created inside the 
&lsquo;<samp>&lt;output&gt;/bin/</samp>&rsquo; directory (where &quot;&lsquo;<samp>&lt;output&gt;</samp>&rsquo;&quot; is the directory where
output from the OMI build is saved. The &lsquo;<samp>libnits.so</samp>&rsquo;, &lsquo;<samp>libnitsstub.a</samp>&rsquo;, 
and &lsquo;<samp>libnitsinj.so</samp>&rsquo; are all present in the &lsquo;<samp>&lt;output&gt;/lib</samp>&rsquo; directory and 
can be used directly from there. 
</p>
<p>In order to run tests in all directories or in a single test directory, you can run:
</p>
<div class="example">
<pre class="example">make tests
</pre></div>

<p>This in turn invokes &lsquo;<samp>nits</samp>&rsquo; with appropriate command-line arguments and runs 
the single test or all test binaries.
</p>
<p>The file &lsquo;<samp>&lt;output&gt;/tmp/nitsargs.txt</samp>&rsquo; contains the command-line arguments passed 
to nits during the test run, if you use the &lsquo;<samp>-file:</samp>&rsquo; option passed to nits to
include it.
</p>
<a name="How-to-Call-Product-APIs"></a>
<h3 class="section">D.5 How to Call Product APIs</h3>

<p>NITS provides facilities to allow private APIs to be callable at will without 
individually exporting all of them. This makes it convenient to link test 
shared libraries directly against product shared libraries, which in turn allows 
simple and reliable code coverage measurements.  The alternative is linking the 
test code to product static libraries, which leads to product code existing in 
many binaries at once.  While this is not technically broken, it is impossible 
to retrieve accurate coverage data in complex cases, and this has some tendency 
to encourage duplication of product code in multiple product binaries.
</p>
<a name="Public-APIs"></a>
<h4 class="subsection">D.5.1 Public APIs</h4>

<p>Public interfaces must be exported somehow. This may be done individually 
for each API, or function tables may be used (as in &lsquo;<samp>mi.h</samp>&rsquo;) to export an 
entire collection of APIs from one binary using a single export macro like 
&lsquo;<samp>MI_EXPORT</samp>&rsquo;. The latter technique leads to smaller binary size but 
requires more care to avoid introducing breaking changes to the contents 
of the table.
</p>
<a name="Private-APIs"></a>
<h4 class="subsection">D.5.2 Private APIs</h4>

<p>Non-public interfaces do not need to be exported in the same way. The 
recommended approach is to place all of the externally callable private APIs 
from a given product binary into a single &lsquo;<samp>NitsTrapTable</samp>&rsquo;, and then 
import that table into all the binaries that call any of the APIs. Macros 
can be used to hide this behavior from the calling binaries. A simple example 
is available in &lsquo;<samp>nits/sample/test.cpp</samp>&rsquo;.
</p>
<a name="How-to-Mock-Product-APIs"></a>
<h3 class="section">D.6 How to Mock Product APIs</h3>

<p>NITS supports mocking private APIs that are already exposed through a function 
table using the &lsquo;<samp>NitsSetTrap</samp>&rsquo; API. The only additional change needed in the 
product is that all mockable calls in the product must invoke through the trap 
table, rather than directly calling the function. When NitsSetTrap is called, the 
function pointer in the table is replaced and all calls through the pointer are 
redirected to the mock. For a simplified proof of concept, see  &lsquo;<samp>AutitTest</samp>&rsquo; 
in &lsquo;<samp>nits/sample/test.spp</samp>&rsquo;.
</p>
<a name="Command-Line-Interface"></a>
<h3 class="section">D.7 Command Line Interface</h3>

<p>The usage pattern for NITS is the following: &lsquo;<samp>nits [option|test]*</samp>&rsquo;. The 
rest of this section describes the available options and test types, along 
with the possible results for each test.
</p>
<a name="Options"></a>
<h4 class="subsection">D.7.1 Options</h4>

<ul>
<li> <b>-bpassert</b>: Issues a breakpoint any time an assertion fails when it should not. 
This is useful for debugging when it takes many steps to walk through the code 
to the point where the assertion fails.
</li><li> <b>-bpfault:number</b>: Issues a breakpoint on a specific fault injection iteration 
number. This option may be used multiple times.
</li><li> <b>-file:name</b>: Appends the contents of name to the command line options.
</li><li> <b>-filter:binary[;binary...]</b>: Prevents the injector from targeting processes 
containing none of the binaries in the filter list.
</li><li> <b>-install</b>: Immediately installs the injector (&lsquo;<samp>libnitsinj.so</samp>&rsquo;) to run 
in all relevant processes created after this point (including upon future boots).
</li><li> <b>-mode:Skip</b>: Explores the test tree and skips all body fixtures.
</li><li> <b>-mode:Enable</b>: (default) Runs test cases without fault injection.
</li><li> <b>-mode:IterativeFault</b>: Runs test cases with Nth site single faults. This option is 
exhaustive for deterministic tests, but very slow.
</li><li> <b>-mode:StackFault</b>: Optimized single fault injection; ignores duplicates based on 
call stack frames.
</li><li> <b>-pause</b>: Waits for user input after running. Useful for holding settings like
&lsquo;<samp>target</samp>&rsquo; and &lsquo;<samp>trace</samp>&rsquo; when doing manual testing.
</li><li> <b>-reset</b>: Ignores a test run in progress and forcibly resets the shared memory 
state. Use this to recover from shared memory corruption.
</li><li> <b>-target:binary[;binary...]</b>: Enables the injector on specific binaries in any 
process.
</li><li> <b>-trace:FailedTests</b>: Shows failed tests only. Least verbose result output.
</li><li> <b>-trace:WarnedTests</b>: Shows failed and warned tests only.
</li><li> <b>-trace:AllTests</b>: Shows all test cases.
</li><li> <b>-trace:Asserts</b>: (default) Shows failed asserts individually.
</li><li> <b>-trace:Warnings</b>: Shows failed asserts and warnings individually.
</li><li> <b>-trace:Iterations</b>: Shows fault injection iteration information and 
asserts/warnings.
</li><li> <b>-trace:Verbose</b>: Shows all of the above plus NitsTrace calls.
</li><li> <b>-uninstall</b>: Removes &lsquo;<samp>libnitsinj.so</samp>&rsquo; injection from all processes. Use this before 
updating NITS binaries.
</li><li> <b>-wtt:file</b>: Logs WTT results to a WTT log file (requires WTT to be installed).
</li><li> <b>-match:testFixtureNameSubstring</b>: Runs tests only if they contain fixture names 
matching the pattern (semicolon or comma-separated).
</li><li> <b>+name:value</b>: Sets test parameter &quot;name&quot; to &quot;value&quot;. Test module can retrieve 
the value of the parameter by using the API NitsTestGetParam by passing the 
parameter name.
</li><li> <b>-fault</b>: This option is used for fault injection.
</li></ul>

<a name="Tests"></a>
<h4 class="subsection">D.7.2 Tests</h4>

<p>Tests may be run using any of the following syntax forms:
</p>
<ul>
<li> <b>libmodule.so</b>: Specifying a file name runs all tests discovered during 
the loading of that library. NITS now accepts relative and absolute paths.
</li><li> <b>libmodule.so:test</b>: Specify the module name and a test name, separated by a 
bang, to run a particular test. This runs all test variations.
</li><li> <b>libmodule.so:+test</b>: Runs all tests in the module starting with the 
specified test.
</li><li> <b>libmodule.so:test/variation</b>: Specify the module name, the test name, 
and a set of variation choices to run one specific test variation. Each valid 
variation name is constructed from the set of choices made according to the 
hierarchy declared in the test code.
</li><li> <b>libmodule.so:*testnameSubstring</b>: Runs all tests whose names contain the 
pattern.
</li></ul>

<p>The simplest way to discover a list of valid test names and variations for a 
particular module is to run the entire module with the &lsquo;<samp>-mode:Skip</samp>&rsquo; option.
</p>
<table class="cartouche" border="1"><tr><td>
<p><b>Note:</b> To run the NITS sample tests, use &lsquo;<samp>nits</samp>&rsquo; as follows:
</p>
<div class="example">
<pre class="example">./output/bin/nits -install -reset -trace \
   -target:libnitssample.so,libnitssampleproduct.so \
   ./output/lib/libnitssample.so
</pre></div>
</td></tr></table>

<a name="Results"></a>
<h4 class="subsection">D.7.3 Results</h4>

<p>Each test variation reports a result to the test framework.  These results are 
printed and then summarized.  The possible test results are as follows:
</p>
<ul>
<li> <b>Faulted</b>: The test passed, and was then run successfully under automatic fault 
simulation.  There were no unexpected successes or failures during the fault 
simulation loop.
</li><li> <b>Passed</b>: The test passed, and automatic fault simulation was not run.
</li><li> <b>Skipped</b>: The test was disabled by the command line or the test setup code, and 
the test body was not run.  However, no errors were encountered during setup 
or cleanup.
</li><li> <b>Omitted</b>: The test declared itself to be irrelevant. These can be safely ignored.
</li><li> <b>Killed</b>: When using the (old) isolate option, a test case was terminated after 
running for too long without reporting a result.
</li><li> <b>Failed</b>: Assertions failed during the test body, or there were unexpected 
successes or failures during automatic fault simulation.
</li><li> <b>Error</b>: Assertions failed during test setup or cleanup, or no assertions were 
attempted during the test body.
</li></ul>

<a name="Implementation"></a>
<h3 class="section">D.8 Implementation</h3>

<p>This section describes how to create basic unit tests under the NITS framework. This 
section shows only the most basic examples, using as few features as possible. See the 
following section for additional examples for advanced features. To run a test DLL 
containing a simple, &quot;hello world&quot; unit test, see the following example:
</p>
<div class="example">
<pre class="verbatim">#include &lt;nits/base/nits.h&gt;

NitsTest(Test1)
  NitsTrace(PAL_T(&quot;Test Body!&quot;));
  NitsAssert(1 == 1, PAL_T(&quot;assert test!&quot;));
  NitsCompare(1, 1, PAL_T(&quot;compare test!&quot;));
  NitsCompareString(PAL_T(&quot;A&quot;), PAL_T(&quot;A&quot;), PAL_T(&quot;string test!&quot;));
  NitsCompareSubstring(PAL_T(&quot;ABC&quot;),PAL_T(&quot;B&quot;),PAL_T(&quot;substring test!&quot;));
NitsEndTest
</pre></div>

<p>The code above contains a simple test body with some basic assertions and traces. Note 
that the assertion descriptions must be Unicode, but some other arguments may be 
either ANSI or Unicode. Inserting this code into &lsquo;<samp>hello.dll</samp>&rsquo; and compiling it 
produces a binary which can be run using the following command:
</p>
<div class="example">
<pre class="verbatim">./output/bin/nits ./output/lib/libhello.so

        [Passed]  ./output/lib/libhello.so:Test1


Summary:
        Faulted:        0
        Passed:         1
        Skipped:        0
        Killed:         0
        Failed:         0
        Error:          0

        Successes:      1
        Failures:       0
        Total:          1
</pre></div>

<p>This listing shows that the test named &lsquo;<samp>Test1</samp>&rsquo; in &lsquo;<samp>libhello.so</samp>&rsquo; was run 
successfully. The test passed because the body ran one or more test assertions, 
all of which succeeded.
</p>
<a name="A-Selection-of-More-Advanced-Features"></a>
<h3 class="section">D.9 A Selection of More Advanced Features</h3>

<p>This section contains a partial list of available NITS features, roughly in order of 
increasing complexity. Each feature can be used independently of the others unless 
otherwise specified.
</p>
<a name="Tracing"></a>
<h4 class="subsection">D.9.1 Tracing</h4>

<p>The API &lsquo;<samp>NitsTrace</samp>&rsquo; is available for tracing messages using the current source 
location as the call site. These messages will appear in &lsquo;<samp>stderr</samp>&rsquo; only if 
tracing is enabled.
</p>
<a name="Assertions"></a>
<h4 class="subsection">D.9.2 Assertions</h4>

<p>The &lsquo;<samp>NitsAssert</samp>&rsquo;, &lsquo;<samp>NitsCompare</samp>&rsquo;, &lsquo;<samp>NitsCompareString</samp>&rsquo;, and 
&lsquo;<samp>NitsCompareSubstring</samp>&rsquo; APIs validate results obtained during the test.
These functions return true if successful, but otherwise they are printed to 
&lsquo;<samp>stderr</samp>&rsquo; if assertions are enabled.
</p>
<a name="Call-Sites"></a>
<h4 class="subsection">D.9.3 Call Sites</h4>

<p>NITS defines a &lsquo;<samp>NitsCallSite</samp>&rsquo; class which is available on all linkages, 
though on some linkages it becomes trivialized.  This class contains a source 
file, line, function name, and call site ID to be used for fault injection and 
source location identification.  The APIs above use the current source line 
(returned by the &lsquo;<samp>NitsHere( )</samp>&rsquo; macro) as the &lsquo;<samp>NitsCallSite</samp>&rsquo;. However, 
this is not appropriate in common helper functions where it is actually the 
caller&quot;s location that is relevant. The following example shows how to carry 
a &lsquo;<samp>CallSite</samp>&rsquo; through to a helper function:
</p>
<div class="example">
<pre class="verbatim">void TestHelper( NitsCallSite cs )
{
  //Prints location of NitsHere( ) below.
  NitsTraceEx( L&quot;Helper function!&quot;, cs, NitsAutomatic );	
}

NitsTest(Test1)
    TestHelper(NitsHere());
NitsEndTest
</pre></div>

<p>The macros &lsquo;<samp>NitsTraceEx</samp>&rsquo;, &lsquo;<samp>NitsAssertEx</samp>&rsquo;, &lsquo;<samp>NitsCompareEx</samp>&rsquo;, 
&lsquo;<samp>NitsCompareStringEx</samp>&rsquo;, and &lsquo;<samp>NitsCompareSubstringEx</samp>&rsquo; are available for 
this purpose, each taking the same argument list as their counterparts, plus a 
call site argument. &lsquo;<samp>NitsCallSite</samp>&rsquo; objects may be created easily using 
either the &lsquo;<samp>NitsHere( )</samp>&rsquo; or &lsquo;<samp>NitsNamedCallSite</samp>&rsquo; macros. For manual 
fault simulation, use &lsquo;<samp>NitsNamedCallSite(id)</samp>&rsquo;, where the site ID is 
defined by the application.  Otherwise, &lsquo;<samp>NitsHere( )</samp>&rsquo;, which is anonymous, 
generally suffices.
</p>
<a name="Fixtures"></a>
<h4 class="subsection">D.9.4 Fixtures</h4>

<p>NITS tests are made from one or more <b>Fixtures</b>.  Fixtures are reusable units of 
test code.  They support composability; <em>i.e.</em> they can be composed out of other 
fixtures.  They also allow you to share data between each other by letting you 
associate a type(a C &lsquo;<samp>struct</samp>&rsquo;) with them and providing an initialization value 
for that type. There are various types of fixtures:
</p>
<ul>
<li> <b>Setup</b>
</li><li> <b>Split</b>
</li><li> <b>Test</b>
</li><li> <b>Cleanup</b>
</li><li> <b>ModuleSetup</b>
</li></ul>

<p>These types of fixtures are described in the following sections, along with an
illustration of how you can share data between fixtures using an auto-created 
abstraction called a &lsquo;<samp>NitsContext( )</samp>&rsquo;.
</p>
<a name="Setup-Fixtures"></a>
<h4 class="subsection">D.9.5 Setup Fixtures</h4>

<a name="Basic-Setup-Fixtures"></a>
<h4 class="subsubsection">D.9.5.1 Basic Setup Fixtures</h4>

<p>The most basic setup fixture involves bracketing some test code between 
&lsquo;<samp>NitsSetup(&lt;fixtureName&gt;)</samp>&rsquo; and &lsquo;<samp>NitsEndSetup</samp>&rsquo; macros. Here is 
an example of such a fixture:
</p>
<div class="example">
<pre class="verbatim">NitsSetup(SimpleSetup)
        NitsTrace(PAL_T(&quot;SimpleSetup being run&quot;));
NitsEndSetup
</pre></div>

<ul>
<li> &lsquo;<samp>SimpleSetup</samp>&rsquo; is the name of the fixture.
</li><li> &lsquo;<samp>NitsSetup</samp>&rsquo; and &lsquo;<samp>NitsEndSetup</samp>&rsquo; form the start and end of the Setup fixture.
</li><li> The part in between represents the body of the Setup fixture that is run 
during the test run.
</li></ul>

<table class="cartouche" border="1"><tr><td>
<p><b>Note:</b> &lsquo;<samp>NitsEndSetup</samp>&rsquo; and similar end macros are part of every fixture, 
and they help NITS provide a function continuation style of usage, in which 
all the fixtures from which your test is composed are on the same stack. 
This lets you use local variables throughout the entire lifetime of the test.
</p></td></tr></table>

<a name="Associating-a-Data-Type-with-a-Setup-Fixture"></a>
<h4 class="subsubsection">D.9.5.2 Associating a Data Type with a Setup Fixture</h4>

<p>To associate a data type with a Setup fixture, you need to define a C &lsquo;<samp>struct</samp>&rsquo; 
as the data type, and write test code between the &lsquo;<samp>NitsSetup0( &lt;fixtureName&gt;, 
&lt;name of the data type&gt; )</samp>&rsquo; and &lsquo;<samp>NitsEndSetup</samp>&rsquo; macros. Below is an example that 
shows how to associate a type with a Setup fixture:
</p> 
<div class="example">
<pre class="verbatim">struct MyStruct
{
    int x;
};
NitsSetup0( Fixture0, MyStruct )
    NitsContext( )-&gt;_MyStruct-&gt;x = 0;
NitsEndSetup
</pre></div>

<ul>
<li> &lsquo;<samp>Fixture0</samp>&rsquo; is the name of the fixture.
</li><li> &lsquo;<samp>NitsSetup0</samp>&rsquo; and &lsquo;<samp>NitsEndSetup</samp>&rsquo; start and end the Setup fixture. The 
numeral &lsquo;<samp>0</samp>&rsquo; indicates that it is composed of zero other fixtures. As explained below,  
&lsquo;<samp>NitsSetup&lt;N</samp>&rsquo; is used to define Setup fixtures composed of &lsquo;<samp>N</samp>&rsquo; other fixtures.
</li><li> &lsquo;<samp>MyStruct</samp>&rsquo; defines a C &lsquo;<samp>struct</samp>&rsquo; that is then associated with 
&lsquo;<samp>Fixture0</samp>&rsquo; as its data type.
</li><li> Once you associate a data type with a Setup fixture, NITS auto-creates an object 
of the type specified by &lsquo;<samp>MyStruct</samp>&rsquo; and makes it available within the 
&lsquo;<samp>NitsContext( )</samp>&rsquo; abstraction.
</li><li> The &lsquo;<samp>NitsContext( )</samp>&rsquo; will have an auto-created variable with a name 
composed of an underscore followed by the data-type name (<em>e.g.</em> in this example 
&lsquo;<samp>_MyStruct</samp>&rsquo;). This variable is a pointer to the auto-created data object, and 
can be used for data sharing between fixtures.
</li><li> As seen in the example below, &lsquo;<samp>(NitsContext()-&gt;_MyStruct-&gt;x)</samp>&rsquo; lets you access 
the &lsquo;<samp>int x</samp>&rsquo; from the auto-created object of type &lsquo;<samp>MyStruct</samp>&rsquo; that is pointed to 
by the variable &lsquo;<samp>_MyStruct</samp>&rsquo; within &lsquo;<samp>NitsContext( )</samp>&rsquo;.
</li></ul>

<a name="Setup-Fixture-Composition"></a>
<h4 class="subsubsection">D.9.5.3 Setup Fixture Composition</h4>

<p>The syntax for composing a Setup fixture with 1 other child fixture wold begin with the 
start macro:
</p>
<div class="example">
<pre class="verbatim">NitsSetup1( &lt;fixtureName&gt;,
            &lt;name of fixture data Type&gt;,
            &lt;name of child fixture 1&gt;,
            &lt;initialization value for child fixture 1&gt; )
</pre></div>

<p>The test code would follow, and be ended by the &lsquo;<samp>NitsEndSetup</samp>&rsquo; macro.
</p>
<p>Below is an example of how to compose a fixture from one other child fixture while also 
associating a data type with each fixture so that you can pass data back and forth in 
either direction:
</p>
<div class="example">
<pre class="verbatim">struct FooStruct1
{
  int i1;
};

struct FooStruct2
{
  int i2;
};

NitsSetup0( FooSetup1, FooStruct1 )
  NitsAssert(NitsContext()-&gt;_FooStruct1-&gt;i1 == 10,
             PAL_T(&quot;wrong value&quot;));
  NitsContext()-&gt;_FooStruct1-&gt;i1 = 15;
  NitsTrace(PAL_T(&quot;FooSetup1 being run&quot;));            
NitsEndSetup

struct FooStruct1 sFooStruct1 = {10};

NitsSetup1( FooSetup2, FooStruct2, FooSetup1, sFooStruct1 )
  NitsAssert(NitsContext()-&gt;_FooSetup1-&gt;_FooStruct1-&gt;i1 == 15,
             PAL_T(&quot;wrong value&quot;));
  NitsContext()-&gt;_FooSetup1-&gt;_FooStruct1-&gt;i1 = 35;
  NitsContext()-&gt;_FooStruct2-&gt;i2 = 25;
  NitsTrace(PAL_T(&quot;FooSetup2 being run&quot;));        
NitsEndSetup
</pre></div>

<ul>
<li> Here &lsquo;<samp>FooSetup1</samp>&rsquo; and &lsquo;<samp>FooSetup2</samp>&rsquo; are the names of the two 
Setup fixtures.
</li><li> &lsquo;<samp>FooSetup1</samp>&rsquo; uses the &lsquo;<samp>NitsSetup0/NitsEndSetup</samp>&rsquo; syntax, 
since it is not composed of any other fixtures.
</li><li> &lsquo;<samp>FooSetup2</samp>&rsquo; is composed of one child fixture, &lsquo;<samp>FooSetup1</samp>&rsquo;, 
and hence uses the &lsquo;<samp>NitsSetup1/NitsEndSetup</samp>&rsquo; syntax.
</li><li> The C &lsquo;<samp>struct FooStruct1</samp>&rsquo; is the data type associated with 
&lsquo;<samp>FooSetup1</samp>&rsquo;.
</li><li> The C &lsquo;<samp>struct FooStruct2</samp>&rsquo; is the data type associated with &lsquo;<samp>FooSetup2</samp>&rsquo;.
</li><li> When composing from one child fixture in &lsquo;<samp>NitsSetup1</samp>&rsquo;, the macro 
parameters are &lsquo;<samp>FooSetup2, FooStruct2, FooSetup1, sFooStruct1</samp>&rsquo;, which represent:

<ul class="no-bullet">
<li>- The name of the fixture.
</li><li>- The data type associated with the fixture.
</li><li>- The name of the child fixture.
</li><li>- The initialization value for the fixture.
</li></ul>

</li><li> The initialization value &lsquo;<samp>sFooStruct1</samp>&rsquo; given to fixture 
&lsquo;<samp>FooSetup1</samp>&rsquo; is automatically populated into the data object pointed 
to by &lsquo;<samp>NitsContext( )-&gt;_FooStruct</samp>&rsquo; when the fixture &lsquo;<samp>FooSetup1</samp>&rsquo; runs. 
Note that the initialization object is used as copy-by-value and it is copied 
into the data object pointed to by &lsquo;<samp>NitsContext( )</samp>&rsquo; of the fixture that 
it is initializing. That is why &lsquo;<samp>FooSetup1</samp>&rsquo; in the above example can 
assert that the value of &lsquo;<samp>NitsContext()-&gt;_FooStruct1-&gt;i1</samp>&rsquo; will be 10 
when it runs.
</li><li> The initialization value for a fixture has to be a compile-time-defined 
global variable of the data type associated with the fixture. Alternately, to 
pass an all-zero initialization value, you can use the NITS-auto-created global 
variable named &lsquo;<samp>&lt;name of fixture&gt;Defaults</samp>&rsquo; (<em>e.g.</em> in this example, 
if the &lsquo;<samp>FooSetup2</samp>&rsquo; fixture wanted to specify an all-zero initialization 
value for &lsquo;<samp>FooSetup1</samp>&rsquo; then it could have used the auto-created object 
named &lsquo;<samp>FooSetup1Defaults</samp>&rsquo;.
</li><li> When a fixture is composed of other child fixtures, the auto-created 
&lsquo;<samp>NitsContext( )</samp>&rsquo; abstraction inside the fixture contains appropriate 
pointers to access the data from all the child fixtures it is composed of. 
The name of the variable inside &lsquo;<samp>NitsContext( )</samp>&rsquo; that points to the 
context of the child fixture takes the form, &lsquo;<samp>_&lt;child fixture name&gt;</samp>&rsquo;.
</li><li> In this example, &lsquo;<samp>NitsContext( )</samp>&rsquo; inside &lsquo;<samp>FooSetup2</samp>&rsquo; has the 
following variables:

<ul class="no-bullet">
<li>- &lsquo;<samp>_FooStruct2</samp>&rsquo;, which is a pointer to the data object of type 
&lsquo;<samp>FooStruct2</samp>&rsquo; auto-created for itself, since the data type associated 
with &lsquo;<samp>FooSetup2</samp>&rsquo; is &lsquo;<samp>FooStruct2</samp>&rsquo;.
</li><li>- &lsquo;<samp>_FooSetup1</samp>&rsquo;, which is a pointer to the &lsquo;<samp>NitsContext( )</samp>&rsquo; 
inside the child fixture &lsquo;<samp>FooSetup1</samp>&rsquo;.
</li><li>- &lsquo;<samp>_FooSetup1</samp>&rsquo; then contains the pointer &lsquo;<samp>_FooStruct1</samp>&rsquo;, which 
is a pointer to the data object associated with the child fixture &lsquo;<samp>FooSetup1</samp>&rsquo;, 
since the data type associated with &lsquo;<samp>_FooSetup1</samp>&rsquo; is &lsquo;<samp>FooStruct1</samp>&rsquo;.
</li></ul>

</li><li> Thus, as seen in the above example, there is data sharing in both directions 
between a fixture and all child fixtures it is composed of. This is critical when 
you want to parameterize fixtures and reuse the same test code written in the 
Setup fixtures with different data values:

<ul class="no-bullet">
<li>- &lsquo;<samp>FooSetup2</samp>&rsquo; can pass an initialization value to &lsquo;<samp>FooSetup1</samp>&rsquo;, 
which it can see when it is run.
</li><li>- &lsquo;<samp>FooSetup1</samp>&rsquo; can modify the values inside the &lsquo;<samp>NitsContext( )</samp>&rsquo; 
associated with it.
</li><li>- &lsquo;<samp>FooSetup2</samp>&rsquo;, which will run after &lsquo;<samp>FooSetup1</samp>&rsquo;, can then read the 
values modified by &lsquo;<samp>FooSetup1</samp>&rsquo; inside &lsquo;<samp>NitsContext( )</samp>&rsquo;.
</li></ul>

</li><li> The macros, &lsquo;<samp>NitsSetup2</samp>&rsquo;, &lsquo;<samp>NitsSetup3</samp>&rsquo;, &lsquo;<samp>NitsSetup4</samp>&rsquo;, and 
&lsquo;<samp>NitsSetup5</samp>&rsquo; let you define Setup fixtures composed of 2, 3, 4, or 5 child 
fixtures. They use similar syntax:

<div class="example">
<pre class="verbatim">NitsSetup&lt;2/3/4/5&gt;( &lt;fixtureName&gt;,
                    &lt;dataTypeOfFixture&gt;,
                    &lt;child fixture1, 
                      &lt;initialization value of child fixture1&gt;,
                    &lt;child fixture2&gt;,
                      &lt;initialization value of child fixture2&gt;,
                    &lt;child fixture3&gt;,
                      &lt;initialization value of child fixture3&gt;,
                    &lt;child fixture4&gt;, 
                      &lt;initialization value of child fixture4&gt;,
                    &lt;child fixture5&gt;,
                      &lt;initialization value of child fixture5&gt; )
</pre></div>
                      
</li><li> Note that when a specific Setup fixture runs, all child Setup fixtures 
that it is composed of will be run in left to right order of their definition 
<b>before</b> the fixture itself runs. All of them will run on the same stack, 
one above the other, and as a result, you can pass pointers to local variables 
around within &lsquo;<samp>NitsContext( )</samp>&rsquo;. All local variables in child fixtures are 
still available when the parent fixture runs. The stack trace below shows how 
the stack might look like when running the fixtures above:

<div class="example">
<pre class="verbatim">(gdb) bt
#0  FooSetup2 (_NitsContext=0x60e990) 
       at NitsNewInterfaceTests.cpp:489
#3  0x00007ffff76c4e3b in FooSetup1 (_NitsContext=0x60e950)
       at NitsNewInterfaceTests.cpp:485
#13 0x0000000000400dd2 in main (argc=6, argv=0x7fffffffe558) at nits.cpp:146 
</pre></div>

</li><li> If you do not want to associate a data type with a specific Setup fixture, 
you can use the NITS-defined empty data type &lsquo;<samp>NitsEmptyStruct</samp>&rsquo; as the data 
type and the NITS-defined initialization value &lsquo;<samp>NitsEmptyValue</samp>&rsquo; to 
initialize the empty data type fixture.
</li></ul>

<a name="How-to-Re_002duse-Setup-Fixtures-in-Multiple-Files"></a>
<h4 class="subsubsection">D.9.5.4 How to Re-use Setup Fixtures in Multiple Files</h4>

<p>The &lsquo;<samp>NitsDeclSetup&lt;N&gt;/NitsDefSetup&lt;N&gt;</samp>&rsquo; macros allow you declare 
fixtures in a &lsquo;<samp>.h</samp>&rsquo; file and define them in &lsquo;<samp>.cpp</samp>&rsquo; files. 
This lets you reuse the same Setup fixture in multiple files.
</p>
<p>Here is an example:
</p>
<div class="example">
<pre class="verbatim">Foo.h =&gt;

struct MyStruct
{
    int x;
}; 

NitsDeclSetup0(Fixture0, MyStruct);

Foo.cpp =&gt;

NitsDefSetup0(Fixture0, MyStruct)
    NitsContext()-&gt;_MyStruct-&gt;x = 0;
NitsEndSetup
</pre></div>

<ul>
<li> In the above example, &lsquo;<samp>Fixture0</samp>&rsquo; is declared with data type 
&lsquo;<samp>MyStruct</samp>&rsquo; in &lsquo;<samp>Foo.h</samp>&rsquo;.
</li><li> &lsquo;<samp>Fixture0</samp>&rsquo; is defined in &lsquo;<samp>Foo.cpp</samp>&rsquo;.
</li><li> Note that &lsquo;<samp>Fixture0</samp>&rsquo; can be used in other &lsquo;<samp>.cpp</samp>&rsquo; files to 
construct other Setup/Split/Test fixtures.
</li></ul>

<a name="Split-Fixtures"></a>
<h4 class="subsection">D.9.6 Split Fixtures</h4>

<p>Using Split fixtures, you can split the execution of tests into two or more tests. 
This lets you execute the same test code in multiple configurations. A Split fixture 
that splits a test into two child fixtures starts with a &lsquo;<samp>NitsSplit2</samp>&rsquo; macro 
having the following syntax:
</p>
<div class="example">
<pre class="verbatim">NitsSplit2( &lt;fixtureName&gt;,
            &lt;data type of fixture&gt;,
            &lt;name of child fixture 1&gt;,
            &lt;name of child fixture 2&gt; )
</pre></div>

<p>Place the test code after this macro, and end it with the &lsquo;<samp>NitsEndSplit</samp>&rsquo; macro.
</p>
<p>Below is an example of a Split fixture composed of two child fixtures that define 
two child configurations in which the test will run:
</p> 
<div class="example">
<pre class="verbatim">struct MyContext
{
    int a;
};

NitsSetup0(MySetup1, MyContext)
    NitsContext()-&gt;_MyContext-&gt;a = 4;
NitsEndSetup

NitsSetup0(MySetup2, MyContext)
    NitsContext()-&gt;_MyContext-&gt;a = 8;  
NitsEndSetup 

NitsSplit2(MySplitSetup, MyContext, MySetup1, MySetup2)
    NitsAssert((NitsContext()-&gt;_MyContext-&gt;a == 4) || (NitsContext()-
&gt;_MyContext-&gt;a == 8), PAL_T(&quot;value is wrong&quot;));
NitsEndSplit
</pre></div>

<ul>
<li> Here &lsquo;<samp>MySetup1</samp>&rsquo; and &lsquo;<samp>MySetup2</samp>&rsquo; are two Setup fixtures that 
have data type &lsquo;<samp>MyContext</samp>&rsquo;.
</li><li> Each of them assigns a value of 4 or 8 to the variable &lsquo;<samp>a</samp>&rsquo; inside 
the &lsquo;<samp>NitsContext</samp>&rsquo; data object.
</li><li> The &lsquo;<samp>NitsSplit2/NitsEndSplit</samp>&rsquo; macros provide syntax for defining a 
Split fixture. &lsquo;<samp>MySplitSetup</samp>&rsquo; is a Split fixture that lets you split the 
test into two Setup fixtures &lsquo;<samp>MySetup1</samp>&rsquo; and &lsquo;<samp>MySetup2</samp>&rsquo;.
</li><li> NITS automatically runs the test in the &lsquo;<samp>MySplitSetup</samp>&rsquo; fixture 
in two configurations, once with &lsquo;<samp>MySetup1</samp>&rsquo; and next with &lsquo;<samp>MySetup2</samp>&rsquo;.
</li><li> Note that the Split fixture must have the same data type as the two or 
more child fixtures it is composed of. In this example, that data type is the 
C &lsquo;<samp>struct MyContext</samp>&rsquo;.
</li><li> Note that the split fixture syntax doesn&rsquo;t allow you to pass an 
initialization value to the child fixtures. This is because the initialization 
value in the child fixtures will be the same as the initialization value that 
the split fixture gets from the parent fixture.
</li><li> NITS makes sure that the &lsquo;<samp>NitsContext( )-&gt;_MyContext</samp>&rsquo; inside the 
split fixture &lsquo;<samp>MySplitSetup</samp>&rsquo; automatically points to the correct child 
fixture&rsquo;s context (&lsquo;<samp>MySetup1</samp>&rsquo; or &lsquo;<samp>MySetup2</samp>&rsquo;&rsquo;s context) when the test 
is run. This allows you to assert that the value of 
&lsquo;<samp>NitsContext( )-&gt;_MyContext-&gt;a</samp>&rsquo; will be either 4 or 8 when running 
&lsquo;<samp>MySplitSetup</samp>&rsquo; since the child fixtures &lsquo;<samp>MySetup1/MySetup2</samp>&rsquo; 
set it up that way by updating it to 4 and 8 respectively.
</li><li> The &lsquo;<samp>NitsSplit3</samp>&rsquo;, &lsquo;<samp>NitsSplit4</samp>&rsquo;, and &lsquo;<samp>NitsSplit5</samp>&rsquo; macros 
let you define split fixtures which will split into 3, 4, and 5 other child 
fixtures and follow a similar syntax:

<div class="example">
<pre class="verbatim">NitsSplit&lt;3 or 4 or 5&gt;( &lt;fixtureName&gt;, 
                        &lt;data type of fixture&gt;,
                        &lt;name of child fixture 1&gt;,
                        &lt;name of child fixture 2&gt;, 
                        &lt;name of child fixture 3&gt;,
                        &lt;name of child fixture 4&gt;, 
                        &lt;name of child fixture 5&gt; )
</pre></div>
                        
</li><li> Similar to Setup fixtures, you can also separate the declaration and 
definition of Split fixtures by using the 
&lsquo;<samp>NitsDeclSplit&lt;N&gt;/NitsDefSplit&lt;N&gt;</samp>&rsquo; macros.
</li><li> Some common usage scenarios for Split Fixtures are:

<ul class="no-bullet">
<li>- You have a client server test which you need to run with the server 
started in different configurations (<em>e.g.</em> hosted in a Windows service 
or in the test process itself, or in IIS).
</li><li>- You have some test that you need to run over multiple Auth modes or 
different character sets, or over different protocols like HTTP, HTTPs, 
and so on.
</li></ul>
</li></ul>

<a name="Test-Fixtures"></a>
<h4 class="subsection">D.9.7 Test Fixtures</h4>

<p>Test is just one other kind of fixture in NITS. The implementation section 
above already defined &lsquo;<samp>NitsTest/NitsEndTest</samp>&rsquo; syntax for basic tests in NITS. 
This section describes syntax for more advanced tests that are composed of one 
or more other &lsquo;<samp>Setup</samp>&rsquo; or &lsquo;<samp>Split</samp>&rsquo; fixtures. A Test fixture composed 
of one child fixture starts with a &lsquo;<samp>NitsTest1</samp>&rsquo; macro having the following
syntax:
</p>
<div class="example">
<pre class="verbatim">NitsTest1( &lt;testFixtureName&gt;,
           &lt;child fixture 1&gt;, 
           &lt;initializer for child fixture 1&gt; )
</pre></div>

<p>Test code follows, and the fixture is ends with the &lsquo;<samp>NitsEndTest</samp>&rsquo; macro.
Here is an example:
</p>
<div class="example">
<pre class="verbatim">struct FooStruct1
{
  int i1;
};

NitsSetup0(FooSetup1, FooStruct1)
  NitsAssert(NitsContext()-&gt;_FooStruct1-&gt;i1 == 20, PAL_T(&quot;wrong value&quot;));
  NitsContext()-&gt;_FooStruct1-&gt;i1 = 35;
NitsEndSetup

struct FooStruct1 sFooStruct1 = {20};

NitsTest1(FooTest, FooSetup1, sFooStruct1)
    NitsAssert( NitsContext()-&gt;_FooSetup1-&gt;_FooStruct1-&gt;i1 == 35,
                PAL_T(&quot;wrong value&quot;));    
NitsEndTest
</pre></div>

<ul>
<li> In the above example, &lsquo;<samp>FooSetup1</samp>&rsquo; is a setup fixture with data 
type &lsquo;<samp>FooStruct1</samp>&rsquo;.
</li><li> The &lsquo;<samp>NitsTest1/NitsEndTest</samp>&rsquo; macro pair determine the syntax for 
defining a test composed out of one child fixture.
</li><li> &lsquo;<samp>FooTest</samp>&rsquo; is the name of the test, which is composed of 
&lsquo;<samp>FooSetup1</samp>&rsquo; and passes &lsquo;<samp>sFooStruct1</samp>&rsquo; as the initialization value 
to &lsquo;<samp>FooSetup1</samp>&rsquo;.
</li><li> When the test is run, &lsquo;<samp>FooSetup1</samp>&rsquo; runs first, followed by 
&lsquo;<samp>FooTest</samp>&rsquo; on the same stack, as mentioned earlier.
</li><li> &lsquo;<samp>NitsContext( )</samp>&rsquo; inside the test body also follows a format 
similar to that of a Setup fixtures, in that it has auto-created variables 
of the format &lsquo;<samp>_&lt;Child fixture name&gt;</samp>&rsquo; that point to &lsquo;<samp>NitsContext( )</samp>&rsquo; 
data objects inside the child fixture.
</li><li> Note that there is no data type associated with a Test fixture; its 
&lsquo;<samp>NitsContext( )</samp>&rsquo; only lets you access the &lsquo;<samp>NitsContext( )</samp>&rsquo; data 
objects inside child fixtures.
</li><li> In above example, when &lsquo;<samp>FooSetup1</samp>&rsquo; runs, the value of variable 
&lsquo;<samp>i1</samp>&rsquo; inside the &lsquo;<samp>NitsContext( )-&gt;_FooStruct1</samp>&rsquo; data object is 20, 
since the test passes initializer &lsquo;<samp>sFooStruct1</samp>&rsquo; which sets it to 20.
</li><li> &lsquo;<samp>FooSetup1</samp>&rsquo; itself then updates &lsquo;<samp>i1</samp>&rsquo; to 35.
</li><li> Therefore, when the test body runs, the value of &lsquo;<samp>i1</samp>&rsquo; is 35. This 
illustrates data sharing between a Test fixture and its children in both directions.
</li><li> The &lsquo;<samp>NitsTest2</samp>&rsquo;, &lsquo;<samp>NitsTest3</samp>&rsquo;, &lsquo;<samp>NitsTest4</samp>&rsquo;, and &lsquo;<samp>NitsTest5</samp>&rsquo; 
macros let you define tests composed of 2, 3, 4, and 5 Setup/Split child 
fixtures. Child fixtures are run in the left-to-right direction in 
which they are defined. These macros use a syntax like the following:
 
<div class="example">
<pre class="verbatim">NitsTest&lt;2 or 3 or 4 or 5&gt;( &lt;testfixtureName&gt;,
                            &lt;child fixture 1&gt;, 
                            &lt;initializer for child fixture 1&gt;, 
                            &lt;child fixture 2&gt;, 
                            &lt;initializer for child fixture 2&gt;, 
                            &lt;child fixture 3&gt;, 
                            &lt;initializer for child fixture 3&gt;, 
                            &lt;child fixture 4&gt;, 
                            &lt;initializer for child fixture 4&gt;, 
                            &lt;child fixture 5&gt;, 
                            &lt;initializer for child fixture 5&gt; )
</pre></div>

</li><li> The &lsquo;<samp>NitsTestWithSetup</samp>&rsquo; macro lets you define a simple test fixture 
composed of a child Setup fixture defined using &lsquo;<samp>NitsSetup</samp>&rsquo;. 
&lsquo;<samp>NitsTestWithInitializableSetup</samp>&rsquo; lets you define a test composed of one 
Setup fixture taking initialization data. For all the &lsquo;<samp>Nits*</samp>&rsquo; macro 
definitions, see the &lsquo;<samp>nits.h</samp>&rsquo; header file in the &lsquo;<samp>admin/wmi/winomi/nits/base/</samp>&rsquo;
directory.
</li><li> Note that the interface lets you construct arbitrary directed acyclic 
graphs (DAGs) of Test fixtures. It is possible that the same Setup/Split fixture 
can appear multiple times in such a graph without causing any problem, because 
NITS instantiates and runs a fixture only once. As a result, you can be sure 
of not having multiple executions of the same fixture or having multiple copies 
of its &lsquo;<samp>NitsContext( )</samp>&rsquo; object.
</li></ul>

<a name="Cleanup-Fixtures"></a>
<h4 class="subsection">D.9.8 Cleanup Fixtures</h4>

<p>Cleanup fixture can be defined on any of the above type of fixtures (<em>i.e.</em> on 
Setup, Split, Test, or ModuleSetup fixtures). The Cleanup fixture is run at the end 
of the test body for Setup, Split, and Test fixtures, and at the end of the test 
module for ModuleSetup fixtures. Because a Cleanup fixture has access to the same 
&lsquo;<samp>NitsContext( )</samp>&rsquo; as the fixture for which it is cleaning up, you can use it 
to clean up anything you need to. 
</p>
<p>A Cleanup fixture begins with a &lsquo;<samp>NitsCleanup</samp>&rsquo; macro that uses the following
syntax:
</p>
<div class="example">
<pre class="verbatim">NitsCleanup( &lt;fixtureName for which the Cleanup fixture is defined&gt; )
</pre></div>

<p>The code for the body of the test follows this start macro, and &lsquo;<samp>NitsEndCleanup</samp>&rsquo;. 
Here is an example:
</p>
<div class="example">
<pre class="verbatim">NitsSetup(MySetup1)
  NitsTrace(PAL_T(&quot;MySetup1 being run&quot;));
NitsEndSetup

NitsCleanup(MySetup1)
  NitsTrace(PAL_T(&quot;Cleanup for MySetup1 being run&quot;));
NitsEndCleanup
</pre></div>

<ul>
<li> Here the Cleanup is defined on a Setup fixture, &lsquo;<samp>MySetup1</samp>&rsquo;.
</li><li> The syntax starts with the &lsquo;<samp>NitsCleanup</samp>&rsquo; macro, and ends with the 
&lsquo;<samp>NitsEndCleanup</samp>&rsquo; macro.
</li><li> The name of the Cleanup fixture is same as the fixture for which it is 
defined.
</li><li> In a test hierarchy, each fixture could have a Cleanup fixture defined. 
In that case the Cleanup fixtures are run in the reverse order in which the fixtures 
themselves are executed (<em>e.g.</em> &lsquo;<samp>Setup1=&gt;Test1=&gt;Cleanup(Test1)=&gt;Cleanup(Setup1)</samp>&rsquo;.
</li></ul>


<a name="ModuleSetup-Fixtures"></a>
<h4 class="subsection">D.9.9 ModuleSetup Fixtures</h4>

<p>ModuleSetup fixtures let you define test code that is run at the beginning and 
end of the test module. This is useful in places where you want to run some piece 
of test code only once per test module at the beginning and end of it.
</p>
<p>Here is an example:
</p>
<div class="example">
<pre class="verbatim">NitsModuleSetup(MyModuleSetup1)
    NitsTrace(PAL_T(&quot;MyModuleSetup1 being run&quot;));
    NitsAssert(PAL_TRUE, PAL_T(&quot;&quot;));
NitsEndModuleSetup

NitsCleanup(MyModuleSetup1)
    NitsTrace(PAL_T(&quot;Cleanup for MyModuleSetup1 being run&quot;));
NitsEndCleanup
</pre></div>

<ul>
<li> &lsquo;<samp>MyModuleSetup1</samp>&rsquo; defines a ModuleSetup fixture that will be run at 
the beginning of the module in which it is located.
</li><li> As with all other fixtures, you can define Cleanup fixtures also on ModuleSetup 
fixtures. They will be run at the end of the module.
</li><li> You can have multiple ModuleSetup fixtures in a test module(DLL/shared object 
library) and  all of them will be run sequentially at the beginning of the module.
</li><li> In the case of test isolation mode, <em>i.e.</em> running tests in their own 
processes, the ModuleSetup is run per test process.
</li><li> Currently, this feature has limited capabilities. For example, it doesn&rsquo;t let 
you pass data around or compose ModuleSetup fixtures out of other fixtures. There 
are plans to add more functionality in the future.
</li></ul>


<a name="A-Note-about-C_002b_002b-Tests"></a>
<h4 class="subsection">D.9.10 A Note about C++ Tests</h4>

<p>In the case where functions to be tested are inside a class written in C++, you 
need to write C wrappers for those functions. In &lsquo;<samp>class1</samp>&rsquo;:
</p>
<div class="example">
<pre class="verbatim">class class1
{
  int foo1();
};
</pre></div>

<p>The corresponding NITSs C++ file containing traps should look 
something like this:
</p>
<div class="example">
<pre class="verbatim">PAL_BEGIN_EXTERNC
	int class1_foo1()
	{
		class1* obj = construct_class1();
		return obj-&gt;foo1();
	}
	class1* construct_class1()
	{
		return new class1();
	}
PAL_END_EXTERNC

NitsTrapValue(class1Traps)
	class1_foo
NitsEndTrapValue
</pre></div>

<p>The corresponding NITS traps header file should look something like this:
</p>
<div class="example">
<pre class="verbatim">NitsTrapTable(class1Traps,0)
       int (NITS_CALL* _class1_foo)();
NitsEndTrapTable

NitsTrapExport(class1Traps)
</pre></div>


<p>A NITS test for the above product class might look like the following 
(assuming that the product binary is named &lsquo;<samp>libfoo.so</samp>&rsquo;):
</p>
<div class="example">
<pre class="verbatim">struct Ptr
{
  void* ptr;
};

Ptr PtrVal = {NULL};

NitsSetup0(MyModuleSetup1, Ptr)
  NitsTrapHandle h = NitsOpenTrap(&quot;libfoo.so&quot;, class1Traps);
  NitsAssert(h != NULL, PAL_T(&quot;Failed to load cla11Traps&quot;));
  NitsContext()-&gt;_Ptr-&gt;ptr = h;
  
  // Optionally, you could call a helper function too:
  CallHelperFunction()
NitsEndSetup

NitsCleanup(MyModuleSetup1)
	NitsTrapHandle h = NitsContext()-&gt;_Ptr-ptr;
	if(h != NULL)
		NitsCloseTrap(h);
NitsEndCleanup

NitsTest(MyModuleSetup1, PtrVal)
   NitsTrapHandle h = NitsContext()-&gt;_op1-&gt;_Ptr-&gt;ptr;
   int result = NitsGetTrap(h, class1Traps, _class1_foo)();
   NitsAssert(result != 1, PAL_T(&quot;Test failed&quot;));
NitsEndTest
</pre></div>

<a name="Automatic-Fault-Simulation"></a>
<h4 class="subsection">D.9.11 Automatic Fault Simulation</h4>

<p>NITS provides automatic fault simulation functionality, which works as follows:
</p>
<ul>
<li> The user annotates the places where the Faults should be simulated by using 
calls to &lsquo;<samp>NitsShouldFault</samp>&rsquo;.
</li><li> When NITS tests are run with fault simulation enabled (either by using the
&lsquo;<samp>-fault</samp>&rsquo; switch or by using &lsquo;<samp>NitsEnableFaultSim</samp>&rsquo; inside the test body), 
the test body is run multiple times.
</li><li> In the first run, no faults are simulated (<em>i.e.</em> all calls to 
&lsquo;<samp>NitsShouldFault</samp>&rsquo; return FALSE).
</li><li> The test body is then run in a loop multiple times, and in each iteration, 
one specific &lsquo;<samp>NitsShouldFault</samp>&rsquo; call returns TRUE.
</li><li> The user can simulate failure behavior by failing the specific external API 
or internal function when the corresponding &lsquo;<samp>NitsShouldFault</samp>&rsquo; call 
returns TRUE.
</li><li> Below is an example of a function using this functionality.
</li><li> By default, only the test body is only run in a loop. However, if the test body 
uses the macro &lsquo;<samp>NitsFaultSimMarkForRerun</samp>&rsquo;, the entire test hierarchy is run 
in a loop. That helps in scenarios where the Setup/Cleanup fixtures need to be 
executed in every fault simulation iteration.
</li><li> Before running the tests in fault simulation mode, run &lsquo;<samp>nits -install</samp>&rsquo;. 
This sets up a file that indicates to &lsquo;<samp>libnitsstub.a</samp>&rsquo; that it should load 
&lsquo;<samp>libnitsinj.so</samp>&rsquo;, which patches the stubbed version of the NITS API table 
in product and test binaries with the actual NITS implementation.
</li><li> All binaries that are linked with NITS using HOOK_BUILD should be specified 
using the &lsquo;<samp>-target</samp>&rsquo; switch if they need to be fault-simulated.
</li><li> OMI tests already use this functionality for all test binaries.
</li></ul>

<div class="example">
<pre class="verbatim">int Foo()
{
  if(NitsShouldFault(NitsHere(), NitsAutomatic))
  {
    // Simulate failure path behavior
    // failure return
    return -1;       
  }
  // continue with implementation
  
  // success return
  return 0;  
}
</pre></div>

<a name="Enabling-Logging-during-Unit-Testing-with-NITS"></a>
<h3 class="section">D.10 Enabling Logging during Unit Testing with NITS</h3>

<p>On the NITS command line, use the &lsquo;<samp>+loglevel:&lt;value&gt;</samp>&rsquo; option to set the 
level of logging detail (&lsquo;<samp>loglevel</samp>&rsquo;) to one of the following values, which 
are NOT case-sensitive: 
</p> 
<div class="example">
<pre class="example">  0
  1
  2
  3
  4
  5
  FATAL
  ERR
  WARNING
  INFO
  DEBUG
  VERBOSE
</pre></div>
 
<p>For example:
</p> 
<div class="example">
<pre class="example">nits +loglevel:5 test_base.dll
output/bin/nits +loglevel:verbose output/lib/libtest_miapi.so
</pre></div>
 
<p>The resulting log files are saved in the &lsquo;<samp>&lt;topleveldir&gt;/output/var/log/</samp>&rsquo; 
directory as follows:
</p>
<ul>
<li> Logs from &lsquo;<samp>omiserver</samp>&rsquo; appear in &lsquo;<samp>omiserver.log</samp>&rsquo;. Individual 
unit tests start the server when required, and the &lsquo;<samp>loglevel</samp>&rsquo; passed 
in is the same as the test process&quot;s current &lsquo;<samp>loglevel</samp>&rsquo;.
</li><li> Logs from &lsquo;<samp>omiagent</samp>&rsquo; appear in &lsquo;<samp>omiagent*.log</samp>&rsquo;.
</li><li> Logs from tests involving the client stack (using the MI API) appear in 
&lsquo;<samp>miclient.log</samp>&rsquo;.
</li><li> For tests that do not involve the client stack in the test process 
(<em>i.e.</em> everything other than &lsquo;<samp>test_cli</samp>&rsquo; and &lsquo;<samp>test_miapi</samp>&rsquo;), 
the test process prints its logs to &lsquo;<samp>omitest.log</samp>&rsquo;.
</li><li> If you want to see output of test process in the console itself, you can 
use the &lsquo;<samp>+logstderr:1</samp>&rsquo; option on the NITS command line. For example:

<div class="example">
<pre class="example">output/bin/nits +loglevel:verbose +logstderr:1 \
                output/lib/libtest_base.so
</pre></div>

<p>Remember, however, that this works only for tests that do not use the MI API
(<em>i.e.</em> everything other than test_cli and test_miapi). MI-API code 
closes the log every time the test closes the MI application. As a result, 
even if the test library tried to set the log to &lsquo;<samp>stderr</samp>&rsquo; so as to 
print to the console, output would be routed to the &lsquo;<samp>miclient.log</samp>&rsquo; 
every time the MI application closes and re-opens.
</p></li></ul>

<table class="cartouche" border="1"><tr><td>
<p><b>Note:</b> Because &lsquo;<samp>+loglevel:&lt;value&gt;</samp>&rsquo; and &lsquo;<samp>+logstderr:1</samp>&rsquo; are not 
built-in NITS command-line options, they are not included in NITS usage 
help. They are implemented through the NITS module setup/cleanup constructs 
that let us run code at the beginning and end of a test module run. In this
way, we use a common Setup/Cleanup fixture defined inside the 
&lsquo;<samp>ut\</samp>&rsquo; directory to set the loglevels and route the log 
data to &lsquo;<samp>stderr</samp>&rsquo; at the beginning of the module level setup, and to 
close the log during the module level cleanup.
</p></td></tr></table>

<p>Below is an example of using &lsquo;<samp>NitsModuleSetup/NitsCleanup</samp>&rsquo; from 
&lsquo;<samp>ut\omitestcommon.cpp</samp>&rsquo;. You can have multiple module-level 
setups and cleanups in a module. All Module setups will be run at the beginning 
of the test module and all cleanups at the end after running all tests within the module.
</p> 
<div class="example">
<pre class="verbatim">NitsModuleSetup(OMITestSetup)
  NitsTrace(PAL_T(&quot;OMITestSetup being run&quot;));
  if(NitsTestGetParam(PAL_T(&quot;logstderr&quot;)))
  {
    Log_OpenStdErr();
  }
  else
  {
    PAL_Char finalPath[PAL_MAX_PATH_SIZE];
    /* Create name and Open the log file */
    if((CreateLogFileNameWithPrefix(&quot;omitest&quot;, finalPath) != 0) ||
      (Log_Open(finalPath) != MI_RESULT_OK))
    {        
      NitsTrace(
        PAL_T(&quot;failed to open log file; routing output to stderr&quot;));
      Log_OpenStdErr();
    }
  }
  const PAL_Char *loglevelParam = NitsTestGetParam(PAL_T(&quot;loglevel&quot;));
  if(loglevelParam &amp;&amp; Log_SetLevelFromPalCharString(loglevelParam) != 0)
  {
    NitsTrace(
      PAL_T(&quot;loglevel parameter invalid; not setting loglevel&quot;));
    NitsAssert(PAL_FALSE, PAL_T(&quot;loglevel parameter invalid&quot;));
  }
  NitsAssert(PAL_TRUE, PAL_T(&quot;&quot;));
NitsEndModuleSetup
 
NitsCleanup(OMITestSetup)
  NitsTrace(PAL_T(&quot;Cleanup of OMITestSetup being run&quot;));
  Log_Close();
  NitsAssert(PAL_TRUE, PAL_T(&quot;&quot;));
NitsEndCleanup
</pre></div>
 

<hr>



</body>
</html>
